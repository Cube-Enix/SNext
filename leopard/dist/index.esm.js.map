{"version":3,"file":"index.esm.js","sources":["../src/Trigger.js","../src/renderer/Matrix.js","../src/renderer/Skin.js","../src/renderer/Shaders.js","../src/renderer/effectInfo.js","../src/renderer/ShaderManager.js","../src/renderer/PenSkin.js","../src/renderer/Rectangle.js","../src/renderer/BitmapSkin.js","../src/renderer/SpeechBubbleSkin.js","../src/renderer/VectorSkin.js","../src/Costume.js","../src/renderer/SkinCache.js","../src/Color.js","../src/lib/decode-adpcm-audio.js","../src/Sound.js","../src/Sprite.js","../src/Renderer.js","../src/Input.js","../src/Project.js","../src/Watcher.js"],"sourcesContent":["const GREEN_FLAG = Symbol(\"GREEN_FLAG\");\r\nconst KEY_PRESSED = Symbol(\"KEY_PRESSED\");\r\nconst BROADCAST = Symbol(\"BROADCAST\");\r\nconst CLICKED = Symbol(\"CLICKED\");\r\nconst CLONE_START = Symbol(\"CLONE_START\");\r\n\r\nexport default class Trigger {\r\n  constructor(trigger, options, script) {\r\n    this.trigger = trigger;\r\n\r\n    if (typeof script === \"undefined\") {\r\n      this.options = {};\r\n      this._script = options;\r\n    } else {\r\n      this.options = options;\r\n      this._script = script;\r\n    }\r\n\r\n    this.done = false;\r\n    this.stop = () => {};\r\n  }\r\n\r\n  matches(trigger, options) {\r\n    if (this.trigger !== trigger) return false;\r\n    for (let option in options) {\r\n      if (this.options[option] !== options[option]) return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  start(target) {\r\n    this.stop();\r\n\r\n    const boundScript = this._script.bind(target);\r\n\r\n    this.done = false;\r\n    this._runningScript = boundScript();\r\n\r\n    return new Promise(resolve => {\r\n      this.stop = () => {\r\n        this.done = true;\r\n        resolve();\r\n      };\r\n    });\r\n  }\r\n\r\n  step() {\r\n    this.done = this._runningScript.next().done;\r\n    if (this.done) this.stop();\r\n  }\r\n\r\n  static get GREEN_FLAG() {\r\n    return GREEN_FLAG;\r\n  }\r\n  static get KEY_PRESSED() {\r\n    return KEY_PRESSED;\r\n  }\r\n  static get BROADCAST() {\r\n    return BROADCAST;\r\n  }\r\n  static get CLICKED() {\r\n    return CLICKED;\r\n  }\r\n  static get CLONE_START() {\r\n    return CLONE_START;\r\n  }\r\n}\r\n","/* Adapted from gl-matrix\r\n * https://github.com/toji/gl-matrix\r\n */\r\n\r\n// 3x3 transform matrix operations, unrolled 4 da speedz.\r\nexport default class Matrix {\r\n  // Create a new 3x3 transform matrix, initialized to the identity matrix.\r\n  static create() {\r\n    const matrix = new Float32Array(9);\r\n    matrix[0] = 1;\r\n    matrix[4] = 1;\r\n    matrix[8] = 1;\r\n    return matrix;\r\n  }\r\n\r\n  // Translate a matrix by the given X and Y values\r\n  static translate(dst, src, x, y) {\r\n    const a00 = src[0],\r\n      a01 = src[1],\r\n      a02 = src[2],\r\n      a10 = src[3],\r\n      a11 = src[4],\r\n      a12 = src[5],\r\n      a20 = src[6],\r\n      a21 = src[7],\r\n      a22 = src[8];\r\n\r\n    dst[0] = a00;\r\n    dst[1] = a01;\r\n    dst[2] = a02;\r\n\r\n    dst[3] = a10;\r\n    dst[4] = a11;\r\n    dst[5] = a12;\r\n\r\n    dst[6] = x * a00 + y * a10 + a20;\r\n    dst[7] = x * a01 + y * a11 + a21;\r\n    dst[8] = x * a02 + y * a12 + a22;\r\n    return dst;\r\n  }\r\n\r\n  // Rotate a matrix, in radians\r\n  static rotate(dst, src, rad) {\r\n    const a00 = src[0],\r\n      a01 = src[1],\r\n      a02 = src[2],\r\n      a10 = src[3],\r\n      a11 = src[4],\r\n      a12 = src[5],\r\n      a20 = src[6],\r\n      a21 = src[7],\r\n      a22 = src[8],\r\n      s = Math.sin(rad),\r\n      c = Math.cos(rad);\r\n\r\n    dst[0] = c * a00 + s * a10;\r\n    dst[1] = c * a01 + s * a11;\r\n    dst[2] = c * a02 + s * a12;\r\n\r\n    dst[3] = c * a10 - s * a00;\r\n    dst[4] = c * a11 - s * a01;\r\n    dst[5] = c * a12 - s * a02;\r\n\r\n    dst[6] = a20;\r\n    dst[7] = a21;\r\n    dst[8] = a22;\r\n    return dst;\r\n  }\r\n\r\n  // Scale a matrix by the given X and Y values\r\n  static scale(dst, src, x, y) {\r\n    dst[0] = x * src[0];\r\n    dst[1] = x * src[1];\r\n    dst[2] = x * src[2];\r\n\r\n    dst[3] = y * src[3];\r\n    dst[4] = y * src[4];\r\n    dst[5] = y * src[5];\r\n\r\n    dst[6] = src[6];\r\n    dst[7] = src[7];\r\n    dst[8] = src[8];\r\n    return dst;\r\n  }\r\n}\r\n","export default class Skin {\r\n  constructor(renderer) {\r\n    this.renderer = renderer;\r\n    this.gl = renderer.gl;\r\n    this.used = true;\r\n  }\r\n\r\n  // Get the skin's texture for a given (screen-space) scale.\r\n  /* eslint-disable-next-line no-unused-vars */\r\n  getTexture(scale) {\r\n    return null;\r\n  }\r\n\r\n  // Helper function to create a texture from an image and handle all the boilerplate.\r\n  _makeTexture(image, filtering) {\r\n    const gl = this.gl;\r\n    const glTexture = gl.createTexture();\r\n    gl.bindTexture(gl.TEXTURE_2D, glTexture);\r\n    // These need to be set because most sprite textures don't have power-of-two dimensions.\r\n    // Non-power-of-two textures only work with gl.CLAMP_TO_EDGE wrapping behavior,\r\n    // and because they don't support automatic mipmaps, can only use non-mipmap texture filtering.\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filtering);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filtering);\r\n    if (image)\r\n      gl.texImage2D(\r\n        gl.TEXTURE_2D,\r\n        0,\r\n        gl.RGBA,\r\n        gl.RGBA,\r\n        gl.UNSIGNED_BYTE,\r\n        image\r\n      );\r\n\r\n    return glTexture;\r\n  }\r\n\r\n  // Helper function to set this skin's size based on an image that may or may not be loaded.\r\n  _setSizeFromImage(image) {\r\n    if (image.complete) {\r\n      this.width = image.naturalWidth;\r\n      this.height = image.naturalHeight;\r\n    } else {\r\n      image.addEventListener(\"load\", () => {\r\n        this.width = image.naturalWidth;\r\n        this.height = image.naturalHeight;\r\n      });\r\n    }\r\n  }\r\n\r\n  // Clean up any textures or other objets created by this skin.\r\n  destroy() {}\r\n}\r\n","const SpriteShader = {};\r\n\r\nSpriteShader.vertex = `\r\nprecision mediump float;\r\n\r\nattribute vec2 a_position;\r\nuniform mat3 u_transform;\r\nuniform vec2 u_stageSize;\r\n\r\nvarying vec2 v_texCoord;\r\n\r\nvoid main() {\r\n  v_texCoord = vec2(a_position.x, 1.0 - a_position.y);\r\n  gl_Position = vec4((u_transform * vec3(a_position, 1.0)) / vec3(u_stageSize * 0.5, 1.0), 1.0);\r\n}\r\n`;\r\n\r\nSpriteShader.fragment = `\r\nprecision mediump float;\r\n\r\nconst float epsilon = 1e-3;\r\n\r\nuniform sampler2D u_texture;\r\nvarying vec2 v_texCoord;\r\n\r\n#ifdef EFFECT_color\r\nuniform float u_color;\r\n#endif\r\n\r\n#ifdef EFFECT_fisheye\r\nuniform float u_fisheye;\r\n#endif\r\n\r\n#ifdef EFFECT_whirl\r\nuniform float u_whirl;\r\n#endif\r\n\r\n#ifdef EFFECT_pixelate\r\nuniform float u_pixelate;\r\nuniform vec2 u_skinSize;\r\n#endif\r\n\r\n#ifdef EFFECT_mosaic\r\nuniform float u_mosaic;\r\n#endif\r\n\r\n#ifdef EFFECT_brightness\r\nuniform float u_brightness;\r\n#endif\r\n\r\n#ifdef EFFECT_ghost\r\nuniform float u_ghost;\r\n#endif\r\n\r\n#if defined(EFFECT_whirl) || defined(EFFECT_fisheye) || defined(EFFECT_pixelate)\r\nconst vec2 CENTER = vec2(0.5, 0.5);\r\n#endif\r\n\r\n#ifdef DRAW_MODE_COLOR_MASK\r\nuniform vec4 u_colorMask;\r\n\r\n// TODO: Scratch 2.0 and Scratch 3.0's CPU path check if the top 6 bits match,\r\n// which a tolerance of 3/255 should be equivalent to,\r\n// but Scratch's GPU path has a tolerance of 2/255.\r\nconst vec3 COLOR_MASK_TOLERANCE = vec3(3.0 / 255.0);\r\n#endif\r\n\r\n#ifdef EFFECT_color\r\n// Taken from http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\r\nvec3 rgb2hsv(vec3 c)\r\n{\r\n  vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\r\n  vec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);\r\n  vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\r\n\r\n  float d = q.x - min(q.w, q.y);\r\n  float e = 1.0e-10;\r\n  return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\r\n}\r\n\r\nvec3 hsv2rgb(vec3 c)\r\n{\r\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\r\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\r\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\r\n}\r\n#endif\r\n\r\nvoid main() {\r\n  vec2 coord = v_texCoord;\r\n\r\n  #ifdef EFFECT_mosaic\r\n  {\r\n    float mosaicFactor = clamp(floor(abs(u_mosaic + 10.0) / 10.0 + 0.5), 1.0, 512.0);\r\n    coord = fract(coord * mosaicFactor);\r\n  }\r\n  #endif\r\n\r\n  #ifdef EFFECT_pixelate\r\n    vec2 pixSize = u_skinSize / (abs(u_pixelate) * 0.1);\r\n    coord = (floor(coord * pixSize) + CENTER) / pixSize;\r\n  #endif\r\n\r\n  #ifdef EFFECT_whirl\r\n  {\r\n    const float PI_OVER_180 = 0.017453292519943295;\r\n    vec2 offset = coord - CENTER;\r\n    float whirlFactor = max(1.0 - (length(offset) * 2.0), 0.0);\r\n    float whirl = (-u_whirl * PI_OVER_180) * whirlFactor * whirlFactor;\r\n    float s = sin(whirl);\r\n    float c = cos(whirl);\r\n    mat2 rotationMatrix = mat2(c, -s, s, c);\r\n    coord = rotationMatrix * offset + CENTER;\r\n  }\r\n  #endif\r\n\r\n  #ifdef EFFECT_fisheye\r\n  {\r\n    vec2 vec = (coord - CENTER) / CENTER;\r\n    float len = length(vec) + epsilon;\r\n    float factor = max(0.0, (u_fisheye + 100.0) / 100.0);\r\n    float r = pow(min(len, 1.0), factor) * max(1.0, len);\r\n    vec2 unit = vec / len;\r\n    coord = CENTER + (r * unit * CENTER);\r\n  }\r\n  #endif\r\n\r\n  vec4 color = texture2D(u_texture, coord);\r\n\r\n  #if defined(EFFECT_color) || defined(EFFECT_brightness)\r\n  // Un-premultiply color values by alpha channel\r\n  vec3 unmul = color.rgb / color.a;\r\n\r\n  #ifdef EFFECT_color\r\n  {\r\n    vec3 hsv = rgb2hsv(unmul);\r\n    const float minLightness = 0.11 / 2.0;\r\n    const float minSaturation = 0.09;\r\n\r\n    hsv.z = max(minLightness, hsv.z);\r\n    hsv.y = max(minSaturation, hsv.y);\r\n\r\n    hsv.x = mod(hsv.x + (u_color / 200.0), 1.0);\r\n\r\n    unmul = hsv2rgb(hsv);\r\n  }\r\n  #endif\r\n\r\n  #ifdef EFFECT_brightness\r\n  {\r\n    unmul = clamp(unmul + clamp(u_brightness * 0.01, -1.0, 1.0), 0.0, 1.0);\r\n  }\r\n  #endif\r\n\r\n  color = vec4(unmul * color.a, color.a);\r\n\r\n  #endif // defined(defined(EFFECT_color) || defined(EFFECT_brightness))\r\n\r\n  #ifdef DRAW_MODE_COLOR_MASK\r\n  vec3 diff = abs(u_colorMask.rgb - color.rgb);\r\n  if (any(greaterThan(diff, COLOR_MASK_TOLERANCE))) {\r\n    discard;\r\n  }\r\n  #endif\r\n\r\n  #ifdef EFFECT_ghost\r\n  color *= (1.0 - clamp(u_ghost * 0.01, 0.0, 1.0));\r\n  #endif\r\n\r\n  #ifdef DRAW_MODE_SILHOUETTE\r\n  if (color.a == 0.0) {\r\n    discard;\r\n  }\r\n  #endif\r\n\r\n  gl_FragColor = color;\r\n}\r\n`;\r\n\r\nconst PenLineShader = {};\r\n\r\nPenLineShader.vertex = `\r\nprecision mediump float;\r\n\r\nattribute vec2 a_position;\r\n// The X and Y components of u_penPoints hold the first pen point. The Z and W components hold the difference between\r\n// the second pen point and the first. This is done because calculating the difference in the shader leads to floating-\r\n// point error when both points have large-ish coordinates.\r\nuniform vec4 u_penPoints;\r\nuniform vec2 u_penSkinSize;\r\nuniform float u_penSize;\r\nuniform float u_lineLength;\r\n\r\nvarying vec2 v_texCoord;\r\n\r\n// Add this to divisors to prevent division by 0, which results in NaNs propagating through calculations.\r\n// Smaller values can cause problems on some mobile devices.\r\nconst float epsilon = 1e-3;\r\n\r\nvoid main() {\r\n  // Calculate a rotated (\"tight\") bounding box around the two pen points.\r\n  // Yes, we're doing this 6 times (once per vertex), but on actual GPU hardware,\r\n  // it's still faster than doing it in JS combined with the cost of uniformMatrix4fv.\r\n\r\n  // Expand line bounds by sqrt(2) / 2 each side-- this ensures that all antialiased pixels\r\n  // fall within the quad, even at a 45-degree diagonal\r\n  vec2 position = a_position;\r\n  float expandedRadius = (u_penSize * 0.5) + 1.4142135623730951;\r\n\r\n  // The X coordinate increases along the length of the line. It's 0 at the center of the origin point\r\n  // and is in pixel-space (so at n pixels along the line, its value is n).\r\n  v_texCoord.x = mix(0.0, u_lineLength + (expandedRadius * 2.0), a_position.x) - expandedRadius;\r\n  // The Y coordinate is perpendicular to the line. It's also in pixel-space.\r\n  v_texCoord.y = ((a_position.y - 0.5) * expandedRadius) + 0.5;\r\n\r\n  position.x *= u_lineLength + (2.0 * expandedRadius);\r\n  position.y *= 2.0 * expandedRadius;\r\n\r\n  // 1. Center around first pen point\r\n  position -= expandedRadius;\r\n\r\n  // 2. Rotate quad to line angle\r\n  vec2 pointDiff = u_penPoints.zw;\r\n  // Ensure line has a nonzero length so it's rendered properly\r\n  // As long as either component is nonzero, the line length will be nonzero\r\n  // If the line is zero-length, give it a bit of horizontal length\r\n  pointDiff.x = (abs(pointDiff.x) < epsilon && abs(pointDiff.y) < epsilon) ? epsilon : pointDiff.x;\r\n  // The 'normalized' vector holds rotational values equivalent to sine/cosine\r\n  // We're applying the standard rotation matrix formula to the position to rotate the quad to the line angle\r\n  // pointDiff can hold large values so we must divide by u_lineLength instead of calling GLSL's normalize function:\r\n  // https://asawicki.info/news_1596_watch_out_for_reduced_precision_normalizelength_in_opengl_es\r\n  vec2 normalized = pointDiff / max(u_lineLength, epsilon);\r\n  position = mat2(normalized.x, normalized.y, -normalized.y, normalized.x) * position;\r\n\r\n  // 3. Translate quad\r\n  position += u_penPoints.xy;\r\n\r\n  // 4. Apply view transform\r\n  position *= 2.0 / u_penSkinSize;\r\n  gl_Position = vec4(position, 0, 1);\r\n}\r\n`;\r\n\r\nPenLineShader.fragment = `\r\nprecision mediump float;\r\n\r\nuniform sampler2D u_texture;\r\nuniform vec4 u_penPoints;\r\nuniform vec4 u_penColor;\r\nuniform float u_penSize;\r\nuniform float u_lineLength;\r\nvarying vec2 v_texCoord;\r\n\r\nvoid main() {\r\n  // Maaaaagic antialiased-line-with-round-caps shader.\r\n\r\n\t// \"along-the-lineness\". This increases parallel to the line.\r\n\t// It goes from negative before the start point, to 0.5 through the start to the end, then ramps up again\r\n\t// past the end point.\r\n\tfloat d = ((v_texCoord.x - clamp(v_texCoord.x, 0.0, u_lineLength)) * 0.5) + 0.5;\r\n\r\n\t// Distance from (0.5, 0.5) to (d, the perpendicular coordinate). When we're in the middle of the line,\r\n\t// d will be 0.5, so the distance will be 0 at points close to the line and will grow at points further from it.\r\n\t// For the \"caps\", d will ramp down/up, giving us rounding.\r\n\t// See https://www.youtube.com/watch?v=PMltMdi1Wzg for a rough outline of the technique used to round the lines.\r\n\tfloat line = distance(vec2(0.5), vec2(d, v_texCoord.y)) * 2.0;\r\n\t// Expand out the line by its thickness.\r\n\tline -= ((u_penSize - 1.0) * 0.5);\r\n\t// Because \"distance to the center of the line\" decreases the closer we get to the line, but we want more opacity\r\n\t// the closer we are to the line, invert it.\r\n\tgl_FragColor = u_penColor * clamp(1.0 - line, 0.0, 1.0);\r\n}\r\n`;\r\n\r\nexport { SpriteShader, PenLineShader };\r\n","// This file exists to specify a mapping from numeric indices to effect names in all places that require it.\r\nconst effectNames = [\r\n  \"color\",\r\n  \"fisheye\",\r\n  \"whirl\",\r\n  \"pixelate\",\r\n  \"mosaic\",\r\n  \"brightness\",\r\n  \"ghost\"\r\n];\r\n\r\nconst effectBitmasks = {};\r\nfor (let i = 0; i < effectNames.length; i++) {\r\n  effectBitmasks[effectNames[i]] = 1 << i;\r\n}\r\n\r\nexport { effectNames, effectBitmasks };\r\n","import { SpriteShader, PenLineShader } from \"./Shaders.js\";\r\nimport { effectNames, effectBitmasks } from \"./effectInfo.js\";\r\n\r\n// Everything contained in a shader. It contains both the program, and the locations of the shader inputs.\r\nclass Shader {\r\n  constructor(gl, program) {\r\n    this.gl = gl;\r\n    this.program = program;\r\n    this.uniforms = {};\r\n    this.attribs = {};\r\n\r\n    // In order to pass a value into a shader as an attribute or uniform, you need to know its location.\r\n    // This maps the names of attributes and uniforms to their locations, accessible via the `uniforms` and `attribs`\r\n    // properties.\r\n    const numActiveUniforms = gl.getProgramParameter(\r\n      program,\r\n      gl.ACTIVE_UNIFORMS\r\n    );\r\n    for (let i = 0; i < numActiveUniforms; i++) {\r\n      const { name } = gl.getActiveUniform(program, i);\r\n      this.uniforms[name] = gl.getUniformLocation(program, name);\r\n    }\r\n\r\n    const numActiveAttributes = gl.getProgramParameter(\r\n      program,\r\n      gl.ACTIVE_ATTRIBUTES\r\n    );\r\n    for (let i = 0; i < numActiveAttributes; i++) {\r\n      const { name } = gl.getActiveAttrib(program, i);\r\n      this.attribs[name] = gl.getAttribLocation(program, name);\r\n    }\r\n  }\r\n}\r\n\r\nclass ShaderManager {\r\n  constructor(renderer) {\r\n    this.renderer = renderer;\r\n    this.gl = renderer.gl;\r\n\r\n    // We compile shaders on-demand. Create one shader cache per draw mode.\r\n    this._shaderCache = {};\r\n    for (const drawMode of Object.keys(ShaderManager.DrawModes)) {\r\n      this._shaderCache[drawMode] = new Map();\r\n    }\r\n  }\r\n\r\n  // Creates and compiles a vertex or fragment shader from the given source code.\r\n  _createShader(source, type) {\r\n    const gl = this.gl;\r\n    const shader = gl.createShader(type);\r\n    gl.shaderSource(shader, source);\r\n    gl.compileShader(shader);\r\n\r\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\r\n      const info = gl.getShaderInfoLog(shader);\r\n      throw \"Could not compile WebGL program. \\n\" + info;\r\n    }\r\n\r\n    return shader;\r\n  }\r\n\r\n  getShader(drawMode, effectBitmask = 0) {\r\n    const gl = this.gl;\r\n    // Each combination of enabled effects is compiled to a different shader, with only the needed effect code.\r\n    // Check if we've already compiled the shader with this set of enabled effects.\r\n    const shaderMap = this._shaderCache[drawMode];\r\n    if (shaderMap.has(effectBitmask)) {\r\n      return shaderMap.get(effectBitmask);\r\n    } else {\r\n      let shaderCode;\r\n      switch (drawMode) {\r\n        case ShaderManager.DrawModes.DEFAULT:\r\n        case ShaderManager.DrawModes.SILHOUETTE:\r\n        case ShaderManager.DrawModes.COLOR_MASK: {\r\n          shaderCode = SpriteShader;\r\n          break;\r\n        }\r\n\r\n        case ShaderManager.DrawModes.PEN_LINE: {\r\n          shaderCode = PenLineShader;\r\n          break;\r\n        }\r\n      }\r\n\r\n      // Use #define statements for conditional compilation in shader code.\r\n      let define = `#define DRAW_MODE_${drawMode}\\n`;\r\n\r\n      // Add #defines for each enabled effect.\r\n      for (let i = 0; i < effectNames.length; i++) {\r\n        const effectName = effectNames[i];\r\n        if ((effectBitmask & effectBitmasks[effectName]) !== 0) {\r\n          define += `#define EFFECT_${effectName}\\n`;\r\n        }\r\n      }\r\n\r\n      const vertShader = this._createShader(\r\n        define + shaderCode.vertex,\r\n        gl.VERTEX_SHADER\r\n      );\r\n      const fragShader = this._createShader(\r\n        define + shaderCode.fragment,\r\n        gl.FRAGMENT_SHADER\r\n      );\r\n\r\n      // Combine the vertex and fragment shaders into a single GL program.\r\n      const program = gl.createProgram();\r\n      gl.attachShader(program, vertShader);\r\n      gl.attachShader(program, fragShader);\r\n      gl.linkProgram(program);\r\n\r\n      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\r\n        const info = gl.getProgramInfoLog(program);\r\n        throw new Error(\"Could not compile WebGL program. \\n\" + info);\r\n      }\r\n\r\n      const shader = new Shader(gl, program);\r\n      shaderMap.set(effectBitmask, shader);\r\n      return shader;\r\n    }\r\n  }\r\n}\r\n\r\nShaderManager.DrawModes = {\r\n  // Used for drawing sprites normally\r\n  DEFAULT: \"DEFAULT\",\r\n  // Used for \"touching\" tests. Discards transparent pixels.\r\n  SILHOUETTE: \"SILHOUETTE\",\r\n  // Used for \"color is touching color\" tests. Only renders sprite colors which are close to the color passed in, and\r\n  // discards all pixels of a different color.\r\n  COLOR_MASK: \"COLOR_MASK\",\r\n  // Used for drawing pen lines.\r\n  PEN_LINE: \"PEN_LINE\"\r\n};\r\n\r\nexport default ShaderManager;\r\n","import Skin from \"./Skin.js\";\r\nimport ShaderManager from \"./ShaderManager.js\";\r\n\r\nexport default class PenSkin extends Skin {\r\n  constructor(renderer, width, height) {\r\n    super(renderer);\r\n    this.width = width;\r\n    this.height = height;\r\n\r\n    const framebufferInfo = renderer._createFramebufferInfo(\r\n      width,\r\n      height,\r\n      this.gl.NEAREST\r\n    );\r\n    this._framebufferInfo = framebufferInfo;\r\n\r\n    this._lastPenState = {\r\n      size: 0,\r\n      color: [0, 0, 0, 0]\r\n    };\r\n\r\n    this.clear();\r\n  }\r\n\r\n  destroy() {\r\n    const gl = this.gl;\r\n    gl.deleteTexture(this._framebufferInfo.texture);\r\n    gl.deleteFramebuffer(this._framebufferInfo.framebuffer);\r\n  }\r\n\r\n  getTexture() {\r\n    return this._framebufferInfo.texture;\r\n  }\r\n\r\n  penLine(pt1, pt2, color, size) {\r\n    const renderer = this.renderer;\r\n    renderer._setFramebuffer(this._framebufferInfo);\r\n\r\n    const shader = renderer._shaderManager.getShader(\r\n      ShaderManager.DrawModes.PEN_LINE\r\n    );\r\n\r\n    const gl = this.gl;\r\n\r\n    // Set the shader, and check if it actually changed.\r\n    const shaderChanged = renderer._setShader(shader);\r\n\r\n    // These uniforms only need to be set if the shader actually changed.\r\n    if (shaderChanged) {\r\n      gl.uniform2f(shader.uniforms.u_penSkinSize, this.width, this.height);\r\n    }\r\n\r\n    // Only set the pen color if it changed or the shader changed.\r\n    const penColor = color.toRGBANormalized();\r\n    const oldColor = this._lastPenState.color;\r\n    if (\r\n      shaderChanged ||\r\n      penColor[0] !== oldColor[0] ||\r\n      penColor[1] !== oldColor[1] ||\r\n      penColor[2] !== oldColor[2] ||\r\n      penColor[3] !== oldColor[3]\r\n    ) {\r\n      this._lastPenState.color = penColor;\r\n      gl.uniform4f(\r\n        shader.uniforms.u_penColor,\r\n        penColor[0] * penColor[3],\r\n        penColor[1] * penColor[3],\r\n        penColor[2] * penColor[3],\r\n        penColor[3]\r\n      );\r\n    }\r\n\r\n    // Only set the pen size if it changed or the shader changed.\r\n    if (shaderChanged || this._lastPenState.size !== size) {\r\n      this._lastPenState.size = size;\r\n      gl.uniform1f(shader.uniforms.u_penSize, size);\r\n    }\r\n\r\n    const lineDiffX = pt2.x - pt1.x;\r\n    const lineDiffY = pt2.y - pt1.y;\r\n\r\n    gl.uniform4f(\r\n      shader.uniforms.u_penPoints,\r\n      pt1.x,\r\n      pt1.y,\r\n      lineDiffX,\r\n      lineDiffY\r\n    );\r\n\r\n    // Fun fact: Doing this calculation in the shader has the potential to overflow the floating-point range.\r\n    // 'mediump' precision is only required to have a range up to 2^14 (16384), so any lines longer than 2^7 (128)\r\n    // can overflow that, because you're squaring the operands, and they could end up as \"infinity\".\r\n    // Even GLSL's `length` function won't save us here:\r\n    // https://asawicki.info/news_1596_watch_out_for_reduced_precision_normalizelength_in_opengl_es\r\n    const lineLength = Math.sqrt(lineDiffX * lineDiffX + lineDiffY * lineDiffY);\r\n    gl.uniform1f(shader.uniforms.u_lineLength, lineLength);\r\n\r\n    gl.drawArrays(gl.TRIANGLES, 0, 6);\r\n  }\r\n\r\n  clear() {\r\n    this.renderer._setFramebuffer(this._framebufferInfo);\r\n    const gl = this.gl;\r\n    gl.clearColor(0, 0, 0, 0);\r\n    gl.clear(gl.COLOR_BUFFER_BIT);\r\n  }\r\n}\r\n","export default class Rectangle {\r\n  constructor() {\r\n    this.left = -Infinity;\r\n    this.right = Infinity;\r\n    this.bottom = -Infinity;\r\n    this.top = Infinity;\r\n\r\n    return this;\r\n  }\r\n\r\n  static fromBounds(left, right, bottom, top, result) {\r\n    if (!result) result = new Rectangle();\r\n    result.left = left;\r\n    result.right = right;\r\n    result.bottom = bottom;\r\n    result.top = top;\r\n\r\n    return result;\r\n  }\r\n\r\n  // Initialize a bounding box around a sprite given the sprite's transform matrix.\r\n  static fromMatrix(matrix, result) {\r\n    if (!result) result = new Rectangle();\r\n\r\n    // Adapted somewhat from https://github.com/LLK/scratch-render/blob/develop/docs/Rectangle-AABB-Matrix.md\r\n    const xa = matrix[0] / 2;\r\n    const xb = matrix[3] / 2;\r\n    const absx = Math.abs(xa) + Math.abs(xb);\r\n    const sumx = xa + xb + matrix[6];\r\n\r\n    const ya = matrix[1] / 2;\r\n    const yb = matrix[4] / 2;\r\n    const absy = Math.abs(ya) + Math.abs(yb);\r\n    const sumy = ya + yb + matrix[7];\r\n\r\n    result.left = sumx - absx;\r\n    result.right = sumx + absx;\r\n    result.bottom = sumy - absy;\r\n    result.top = sumy + absy;\r\n\r\n    return result;\r\n  }\r\n\r\n  // Push this rectangle out to integer bounds.\r\n  // This takes a conservative approach and will always expand the rectangle outwards.\r\n  snapToInt() {\r\n    this.left = Math.floor(this.left);\r\n    this.right = Math.ceil(this.right);\r\n    this.bottom = Math.floor(this.bottom);\r\n    this.top = Math.ceil(this.top);\r\n\r\n    return this;\r\n  }\r\n\r\n  // Check whether any part of this rectangle touches another rectangle.\r\n  intersects(rect) {\r\n    return (\r\n      this.left <= rect.right &&\r\n      rect.left <= this.right &&\r\n      this.top >= rect.bottom &&\r\n      rect.top >= this.bottom\r\n    );\r\n  }\r\n\r\n  // Check whether a given point is inside this rectangle.\r\n  containsPoint(x, y) {\r\n    return (\r\n      x >= this.left && x <= this.right && y >= this.bottom && y <= this.top\r\n    );\r\n  }\r\n\r\n  // Clamp this rectangle within bounds.\r\n  clamp(left, right, bottom, top) {\r\n    this.left = Math.min(Math.max(this.left, left), right);\r\n    this.right = Math.max(Math.min(this.right, right), left);\r\n    this.bottom = Math.min(Math.max(this.bottom, bottom), top);\r\n    this.top = Math.max(Math.min(this.top, top), bottom);\r\n\r\n    return this;\r\n  }\r\n\r\n  // Compute the union of two rectangles.\r\n  static union(rect1, rect2, result = new Rectangle()) {\r\n    result.left = Math.min(rect1.left, rect2.left);\r\n    result.right = Math.max(rect1.right, rect2.right);\r\n    result.bottom = Math.min(rect1.bottom, rect2.bottom);\r\n    result.top = Math.max(rect1.top, rect2.top);\r\n\r\n    return result;\r\n  }\r\n\r\n  // Compute the intersection of two rectangles.\r\n  static intersection(rect1, rect2, result = new Rectangle()) {\r\n    result.left = Math.max(rect1.left, rect2.left);\r\n    result.right = Math.min(rect1.right, rect2.right);\r\n    result.bottom = Math.max(rect1.bottom, rect2.bottom);\r\n    result.top = Math.min(rect1.top, rect2.top);\r\n\r\n    return result;\r\n  }\r\n\r\n  get width() {\r\n    return this.right - this.left;\r\n  }\r\n\r\n  get height() {\r\n    return this.top - this.bottom;\r\n  }\r\n}\r\n","import Skin from \"./Skin.js\";\r\n\r\nexport default class BitmapSkin extends Skin {\r\n  constructor(renderer, image) {\r\n    super(renderer);\r\n\r\n    this._image = image;\r\n    this._texture = null;\r\n\r\n    this._setSizeFromImage(image);\r\n  }\r\n\r\n  getTexture() {\r\n    // Make sure to handle potentially non-loaded textures\r\n    const image = this._image;\r\n    if (!image.complete) return null;\r\n\r\n    if (this._texture === null) {\r\n      // Use nearest-neighbor (i.e. blocky) texture filtering for bitmaps\r\n      this._texture = super._makeTexture(image, this.gl.NEAREST);\r\n    }\r\n    return this._texture;\r\n  }\r\n\r\n  destroy() {\r\n    if (this._texture !== null) this.gl.deleteTexture(this._texture);\r\n  }\r\n}\r\n","import Skin from \"./Skin.js\";\r\n\r\nconst bubbleStyle = {\r\n  maxLineWidth: 170,\r\n  minWidth: 50,\r\n  strokeWidth: 4,\r\n  padding: 12,\r\n  tailHeight: 12\r\n};\r\n\r\n// TODO: multiline speech bubbles\r\nexport default class SpeechBubbleSkin extends Skin {\r\n  constructor(renderer, bubble) {\r\n    super(renderer);\r\n\r\n    this._canvas = document.createElement(\"canvas\");\r\n    this._texture = this._makeTexture(null, this.gl.LINEAR);\r\n    this._bubble = bubble;\r\n    this._flipped = false;\r\n    this._rendered = false;\r\n    this._renderedScale = 0;\r\n\r\n    this.width = 0;\r\n    this.height = 0;\r\n    this.offsetX = -bubbleStyle.strokeWidth / 2;\r\n    this.offsetY = this.offsetX + bubbleStyle.tailHeight;\r\n\r\n    this._renderBubble(this._bubble);\r\n  }\r\n\r\n  // To ensure proper text measurement and drawing, it's necessary to restyle the canvas after resizing it.\r\n  _restyleCanvas() {\r\n    const ctx = this._canvas.getContext(\"2d\");\r\n    ctx.font = \"16px sans-serif\";\r\n    ctx.textBaseline = \"hanging\";\r\n  }\r\n\r\n  set flipped(flipped) {\r\n    this._flipped = flipped;\r\n    this._rendered = false;\r\n  }\r\n\r\n  _renderBubble(bubble, scale) {\r\n    const canvas = this._canvas;\r\n    const ctx = canvas.getContext(\"2d\");\r\n\r\n    const renderBubbleBackground = (x, y, w, h, r, style) => {\r\n      if (r > w / 2) r = w / 2;\r\n      if (r > h / 2) r = h / 2;\r\n      if (r < 0) return;\r\n\r\n      ctx.beginPath();\r\n      ctx.moveTo(x + r, y);\r\n      ctx.arcTo(x + w, y, x + w, y + h, r);\r\n      ctx.arcTo(x + w, y + h, x + r, y + h, r);\r\n      if (style === \"say\") {\r\n        ctx.lineTo(Math.min(x + 3 * r, x + w - r), y + h);\r\n        ctx.lineTo(x + r / 2, y + h + r);\r\n        ctx.lineTo(x + r, y + h);\r\n      } else if (style === \"think\") {\r\n        ctx.ellipse(x + r * 2.25, y + h, (r * 3) / 4, r / 2, 0, 0, Math.PI);\r\n      }\r\n      ctx.arcTo(x, y + h, x, y, r);\r\n      ctx.arcTo(x, y, x + w, y, r);\r\n      ctx.closePath();\r\n      ctx.stroke();\r\n      ctx.fill();\r\n\r\n      if (style === \"think\") {\r\n        ctx.beginPath();\r\n        ctx.ellipse(\r\n          x + r,\r\n          y + h + (r * 3) / 4,\r\n          r / 3,\r\n          r / 3,\r\n          0,\r\n          0,\r\n          2 * Math.PI\r\n        );\r\n        ctx.stroke();\r\n        ctx.fill();\r\n      }\r\n    };\r\n\r\n    this._restyleCanvas();\r\n\r\n    const { text, style } = bubble;\r\n    const textWidth = ctx.measureText(text).width;\r\n\r\n    const maxWidth = bubbleStyle.maxLineWidth;\r\n    const padding = bubbleStyle.padding;\r\n\r\n    const width = Math.ceil(Math.min(textWidth, maxWidth) + 2 * padding);\r\n    const height = 10 + 2 * padding;\r\n\r\n    this.width = width + bubbleStyle.strokeWidth;\r\n    this.height = height + bubbleStyle.tailHeight + bubbleStyle.strokeWidth;\r\n\r\n    canvas.width = this.width * scale;\r\n    canvas.height = this.height * scale;\r\n\r\n    this._restyleCanvas();\r\n\r\n    const x = bubbleStyle.strokeWidth / 2;\r\n    const y = x;\r\n\r\n    ctx.setTransform(scale, 0, 0, scale, 0, 0);\r\n\r\n    ctx.fillStyle = \"#fff\";\r\n    ctx.strokeStyle = \"#ccc\";\r\n    ctx.lineWidth = bubbleStyle.strokeWidth;\r\n    ctx.save();\r\n    if (this._flipped) {\r\n      ctx.scale(-1, 1);\r\n      ctx.translate(-this.width, 0);\r\n    }\r\n    renderBubbleBackground(x, y, width, height, bubbleStyle.tailHeight, style);\r\n    ctx.restore();\r\n\r\n    ctx.fillStyle = \"#444\";\r\n    ctx.fillText(text, x + padding, y + padding, maxWidth);\r\n\r\n    this._rendered = true;\r\n    this._renderedScale = scale;\r\n  }\r\n\r\n  getTexture(scale) {\r\n    if (!this._rendered || this._renderedScale !== scale) {\r\n      this._renderBubble(this._bubble, scale);\r\n      const gl = this.gl;\r\n      gl.bindTexture(gl.TEXTURE_2D, this._texture);\r\n      gl.texImage2D(\r\n        gl.TEXTURE_2D,\r\n        0,\r\n        gl.RGBA,\r\n        gl.RGBA,\r\n        gl.UNSIGNED_BYTE,\r\n        this._canvas\r\n      );\r\n    }\r\n\r\n    return this._texture;\r\n  }\r\n\r\n  destroy() {\r\n    this.gl.deleteTexture(this._texture);\r\n  }\r\n}\r\n","import Skin from \"./Skin.js\";\r\n\r\n// This means that the smallest mipmap will be 1/(2**4)th the size of the sprite's \"100%\" size.\r\nconst MIPMAP_OFFSET = 4;\r\n\r\nexport default class VectorSkin extends Skin {\r\n  constructor(renderer, image) {\r\n    super(renderer);\r\n\r\n    this._image = image;\r\n    this._canvas = document.createElement(\"canvas\");\r\n\r\n    this._maxTextureSize = renderer.gl.getParameter(\r\n      renderer.gl.MAX_TEXTURE_SIZE\r\n    );\r\n\r\n    this._setSizeFromImage(image);\r\n\r\n    this._mipmaps = new Map();\r\n  }\r\n\r\n  // TODO: handle proper subpixel positioning when SVG viewbox has non-integer coordinates\r\n  // This will require rethinking costume + project loading probably\r\n  _createMipmap(mipLevel) {\r\n    const scale = 2 ** (mipLevel - MIPMAP_OFFSET);\r\n\r\n    // Instead of uploading the image to WebGL as a texture, render the image to a canvas and upload the canvas.\r\n    const canvas = this._canvas;\r\n    const ctx = canvas.getContext(\"2d\");\r\n\r\n    const image = this._image;\r\n    let width = image.naturalWidth * scale;\r\n    let height = image.naturalHeight * scale;\r\n\r\n    width = Math.round(Math.min(width, this._maxTextureSize));\r\n    height = Math.round(Math.min(height, this._maxTextureSize));\r\n\r\n    // Prevent IndexSizeErrors if the image is too small to render\r\n    if (width === 0 || height === 0) {\r\n      this._mipmaps.set(mipLevel, null);\r\n      return;\r\n    }\r\n\r\n    canvas.width = width;\r\n    canvas.height = height;\r\n\r\n    ctx.drawImage(image, 0, 0, width, height);\r\n\r\n    // Use linear (i.e. smooth) texture filtering for vectors\r\n    this._mipmaps.set(mipLevel, this._makeTexture(canvas, this.gl.LINEAR));\r\n  }\r\n\r\n  getTexture(scale) {\r\n    const image = this._image;\r\n    if (!image.complete) return null;\r\n\r\n    // Because WebGL doesn't support vector graphics, substitute a bunch of bitmaps.\r\n    // This skin contains several renderings of its image at different scales.\r\n    // We render the SVG at 0.5x scale, 1x scale, 2x scale, 4x scale, etc. and store those as textures,\r\n    // so we can use the properly-sized texture for whatever scale we're currently rendering at.\r\n    // Math.ceil(Math.log2(scale)) means we use the \"2x\" texture at 1x-2x scale, the \"4x\" texture at 2x-4x scale, etc.\r\n    // This means that one texture pixel will always be between 0.5x and 1x the size of one rendered pixel,\r\n    // but never bigger than one rendered pixel--this prevents blurriness from blowing up the texture too much.\r\n    const mipLevel = Math.max(Math.ceil(Math.log2(scale)) + MIPMAP_OFFSET, 0);\r\n    if (!this._mipmaps.has(mipLevel)) this._createMipmap(mipLevel);\r\n\r\n    return this._mipmaps.get(mipLevel);\r\n  }\r\n\r\n  destroy() {\r\n    for (const mip of this._mipmaps.values()) {\r\n      this.gl.deleteTexture(mip);\r\n    }\r\n  }\r\n}\r\n","export default class Costume {\r\n  constructor(name, url, center = { x: 0, y: 0 }) {\r\n    this.name = name;\r\n    this.url = url;\r\n\r\n    this.img = new Image();\r\n    this.img.crossOrigin = \"Anonymous\";\r\n    this.img.src = this.url;\r\n\r\n    // TODO: this is super janky, but fixing this fully requires restructuring costume loading\r\n    this.isBitmap = !this.url.match(/\\.svg/);\r\n    this.resolution = this.isBitmap ? 2 : 1;\r\n\r\n    this.center = center;\r\n  }\r\n\r\n  get width() {\r\n    return this.img.naturalWidth;\r\n  }\r\n\r\n  get height() {\r\n    return this.img.naturalHeight;\r\n  }\r\n}\r\n","import BitmapSkin from \"./BitmapSkin.js\";\r\nimport SpeechBubbleSkin from \"./SpeechBubbleSkin.js\";\r\nimport VectorSkin from \"./VectorSkin.js\";\r\n\r\nimport Costume from \"../Costume.js\";\r\n\r\n// This is a class which manages the creation and destruction of Skin objects.\r\n// A Skin is the renderer's version of a \"costume\". It is backed by an image, but you render it by getting its texture.\r\n// Different types of Skins can give you textures in different ways.\r\nexport default class SkinCache {\r\n  constructor(renderer) {\r\n    this._renderer = renderer;\r\n    this.gl = renderer.gl;\r\n\r\n    this._skins = new Map();\r\n  }\r\n\r\n  // Begin GC tracing. Any skin retrieved and rendered during tracing will *not* be garbage-collected.\r\n  beginTrace() {\r\n    // Initialize by assuming no texture is used.\r\n    this._skins.forEach(skin => {\r\n      skin.used = false;\r\n    });\r\n  }\r\n\r\n  // End GC tracing. Any skin not retrieved since the tracing begun will be deleted.\r\n  endTrace() {\r\n    this._skins.forEach((skin, key) => {\r\n      if (!skin.used) {\r\n        skin.destroy();\r\n        this._skins.delete(key);\r\n      }\r\n    });\r\n  }\r\n\r\n  // Retrieve a given object (e.g. costume or speech bubble)'s skin. If it doesn't exist, make one.\r\n  getSkin(obj) {\r\n    if (this._skins.has(obj)) {\r\n      const skin = this._skins.get(obj);\r\n      skin.used = true;\r\n      return skin;\r\n    } else {\r\n      let skin;\r\n\r\n      if (obj instanceof Costume) {\r\n        if (obj.isBitmap) {\r\n          skin = new BitmapSkin(this._renderer, obj.img);\r\n        } else {\r\n          skin = new VectorSkin(this._renderer, obj.img);\r\n        }\r\n      } else {\r\n        // If it's not a costume, assume it's a speech bubble.\r\n        skin = new SpeechBubbleSkin(this._renderer, obj);\r\n      }\r\n      this._skins.set(obj, skin);\r\n      return skin;\r\n    }\r\n  }\r\n}\r\n","const clamp = (n, min, max) => Math.max(min, Math.min(max, n));\r\n\r\n// https://www.rapidtables.com/convert/color/rgb-to-hsv.html\r\nfunction rgbToHSV(r, g, b) {\r\n  r /= 255;\r\n  g /= 255;\r\n  b /= 255;\r\n\r\n  const max = Math.max(r, g, b);\r\n  const min = Math.min(r, g, b);\r\n  const delta = max - min;\r\n\r\n  let h = 0;\r\n  if (delta === 0) {\r\n    // Grey. Leave at 0.\r\n  } else if (max === r) {\r\n    h = (((g - b) / delta + 6) % 6) / 6;\r\n  } else if (max === g) {\r\n    h = (((b - r) / delta + 2) % 6) / 6;\r\n  } else if (max === b) {\r\n    h = (((r - g) / delta + 4) % 6) / 6;\r\n  }\r\n\r\n  let s = 0;\r\n  if (max !== 0) {\r\n    s = delta / max;\r\n  }\r\n\r\n  let v = max;\r\n\r\n  return {\r\n    h: h * 100,\r\n    s: s * 100,\r\n    v: v * 100\r\n  };\r\n}\r\n\r\n// https://www.rapidtables.com/convert/color/hsv-to-rgb.html\r\nfunction hsvToRGB(h, s, v) {\r\n  h = (h / 100) * 360;\r\n  s /= 100;\r\n  v /= 100;\r\n\r\n  const c = v * s;\r\n  const x = c * (1 - Math.abs(((h / 60) % 2) - 1));\r\n\r\n  const min = v - c;\r\n\r\n  let r = min;\r\n  let g = min;\r\n  let b = min;\r\n\r\n  if (h < 60) {\r\n    r += c;\r\n    g += x;\r\n  } else if (h < 120) {\r\n    g += c;\r\n    r += x;\r\n  } else if (h < 180) {\r\n    g += c;\r\n    b += x;\r\n  } else if (h < 240) {\r\n    b += c;\r\n    g += x;\r\n  } else if (h < 300) {\r\n    b += c;\r\n    r += x;\r\n  } else if (h < 360) {\r\n    r += c;\r\n    b += x;\r\n  }\r\n\r\n  return {\r\n    r: r * 255,\r\n    g: g * 255,\r\n    b: b * 255\r\n  };\r\n}\r\n\r\nexport default class Color {\r\n  constructor(h = 0, s = 0, v = 0, a = 1) {\r\n    this.h = h;\r\n    this.s = s;\r\n    this.v = v;\r\n    this.a = a;\r\n  }\r\n\r\n  static rgb(r, g, b, a = 1) {\r\n    const { h, s, v } = rgbToHSV(r, g, b);\r\n    return new Color(h, s, v, a);\r\n  }\r\n\r\n  static hsv(h, s, v, a = 1) {\r\n    return new Color(h, s, v, a);\r\n  }\r\n\r\n  static num(n) {\r\n    n = Number(n);\r\n\r\n    // Match Scratch rgba system\r\n    // https://github.com/LLK/scratch-vm/blob/0dffc65ce99307d048f6b9a10b1c31b01ab0133d/src/util/color.js#L45\r\n    const a = (n >> 24) & 0xff;\r\n    const r = (n >> 16) & 0xff;\r\n    const g = (n >> 8) & 0xff;\r\n    const b = n & 0xff;\r\n    return Color.rgb(r, g, b, a > 0 ? a / 255 : 1);\r\n  }\r\n\r\n  // Red\r\n  get r() {\r\n    return hsvToRGB(this.h, this.s, this.v).r;\r\n  }\r\n  set r(r) {\r\n    this._setRGB(r, this.g, this.b);\r\n  }\r\n\r\n  // Green\r\n  get g() {\r\n    return hsvToRGB(this.h, this.s, this.v).g;\r\n  }\r\n  set g(g) {\r\n    this._setRGB(this.r, g, this.b);\r\n  }\r\n\r\n  // Blue\r\n  get b() {\r\n    return hsvToRGB(this.h, this.s, this.v).b;\r\n  }\r\n  set b(b) {\r\n    this._setRGB(this.r, this.g, b);\r\n  }\r\n\r\n  // Alpha\r\n  get a() {\r\n    return this._a;\r\n  }\r\n  set a(a) {\r\n    this._a = clamp(a, 0, 1);\r\n  }\r\n\r\n  // Hue\r\n  get h() {\r\n    return this._h;\r\n  }\r\n  set h(h) {\r\n    this._h = ((h % 100) + 100) % 100;\r\n  }\r\n\r\n  // Shade\r\n  get s() {\r\n    return this._s;\r\n  }\r\n  set s(s) {\r\n    this._s = clamp(s, 0, 100);\r\n  }\r\n\r\n  // Value\r\n  get v() {\r\n    return this._v;\r\n  }\r\n  set v(v) {\r\n    this._v = clamp(v, 0, 100);\r\n  }\r\n\r\n  _setRGB(r, g, b) {\r\n    r = clamp(r, 0, 255);\r\n    g = clamp(g, 0, 255);\r\n    b = clamp(b, 0, 255);\r\n\r\n    const { h, s, v } = rgbToHSV(r, g, b);\r\n\r\n    this.h = h;\r\n    this.s = s;\r\n    this.v = v;\r\n  }\r\n\r\n  toHexString(forceIncludeAlpha = false) {\r\n    const toHexDigits = n => {\r\n      n = clamp(Math.round(n), 0, 255);\r\n\r\n      let str = n.toString(16);\r\n      if (str.length === 1) {\r\n        str = \"0\" + str;\r\n      }\r\n\r\n      return str;\r\n    };\r\n\r\n    let hex = \"#\" + [this.r, this.g, this.b].map(toHexDigits).join(\"\");\r\n    if (forceIncludeAlpha || this.a !== 1) {\r\n      hex += toHexDigits(this.a * 255);\r\n    }\r\n\r\n    return hex;\r\n  }\r\n\r\n  toRGBString(forceIncludeAlpha = false) {\r\n    const rgb = [this.r, this.g, this.b].map(Math.round);\r\n\r\n    if (forceIncludeAlpha || this.a !== 1) {\r\n      return `rgba(${rgb.join(\", \")}, ${this.a})`;\r\n    }\r\n    return `rgb(${rgb.join(\", \")})`;\r\n  }\r\n\r\n  toRGBA() {\r\n    const rgb = hsvToRGB(this._h, this._s, this._v);\r\n    return [rgb.r, rgb.g, rgb.b, this._a * 255];\r\n  }\r\n\r\n  toRGBANormalized() {\r\n    const rgb = hsvToRGB(this._h, this._s, this._v);\r\n    return [rgb.r / 255, rgb.g / 255, rgb.b / 255, this._a];\r\n  }\r\n\r\n  toString() {\r\n    return this.toRGBString();\r\n  }\r\n}\r\n","/**\r\n * The MIT License (MIT)\r\n *\r\n * Copyright (c) 2013-2019 Truman Kilen, Nathan Dinsmore, and Adroitwhiz\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\r\n * this software and associated documentation files (the \"Software\"), to deal in\r\n * the Software without restriction, including without limitation the rights to\r\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\r\n * the Software, and to permit persons to whom the Software is furnished to do so,\r\n * subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\r\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\r\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\n// prettier-ignore\r\nconst ADPCM_STEPS = [\r\n  7, 8, 9, 10, 11, 12, 13, 14, 16, 17, 19, 21, 23, 25, 28, 31, 34, 37, 41, 45, 50, 55, 60, 66, 73, 80, 88, 97, 107,\r\n  118, 130, 143, 157, 173, 190, 209, 230, 253, 279, 307, 337, 371, 408, 449, 494, 544, 598, 658, 724, 796, 876, 963,\r\n  1060, 1166, 1282, 1411, 1552, 1707, 1878, 2066, 2272, 2499, 2749, 3024, 3327, 3660, 4026, 4428, 4871, 5358, 5894,\r\n  6484, 7132, 7845, 8630, 9493, 10442, 11487, 12635, 13899, 15289, 16818, 18500, 20350, 22385, 24623, 27086, 29794,\r\n  32767\r\n];\r\n\r\nconst ADPCM_INDEX = [-1, -1, -1, -1, 2, 4, 6, 8, -1, -1, -1, -1, 2, 4, 6, 8];\r\n\r\nexport default function decodeADPCMAudio(ab, audioContext) {\r\n  const dv = new DataView(ab);\r\n  // WAV magic number\r\n  if (dv.getUint32(0) !== 0x52494646 || dv.getUint32(8) !== 0x57415645) {\r\n    return Promise.reject(new Error(\"Unrecognized audio format\"));\r\n  }\r\n\r\n  const blocks = {};\r\n  const l = dv.byteLength - 8;\r\n  let i = 12;\r\n  while (i < l) {\r\n    blocks[\r\n      String.fromCharCode(\r\n        dv.getUint8(i),\r\n        dv.getUint8(i + 1),\r\n        dv.getUint8(i + 2),\r\n        dv.getUint8(i + 3)\r\n      )\r\n    ] = i;\r\n    i += 8 + dv.getUint32(i + 4, true);\r\n  }\r\n\r\n  const format = dv.getUint16(20, true);\r\n  const sampleRate = dv.getUint32(24, true);\r\n\r\n  if (format === 17) {\r\n    const samplesPerBlock = dv.getUint16(38, true);\r\n    const blockSize = (samplesPerBlock - 1) / 2 + 4;\r\n\r\n    const frameCount = dv.getUint32(blocks.fact + 8, true);\r\n\r\n    const buffer = audioContext.createBuffer(1, frameCount, sampleRate);\r\n    const channel = buffer.getChannelData(0);\r\n\r\n    let sample;\r\n    let index = 0;\r\n    let step, code, delta;\r\n    let lastByte = -1;\r\n\r\n    const offset = blocks.data + 8;\r\n    let i = offset;\r\n    let j = 0;\r\n    // eslint-disable-next-line\r\n    while (true) {\r\n      if ((i - offset) % blockSize === 0 && lastByte < 0) {\r\n        if (i >= dv.byteLength) break;\r\n        sample = dv.getInt16(i, true);\r\n        i += 2;\r\n        index = dv.getUint8(i);\r\n        i += 1;\r\n        i++;\r\n        if (index > 88) index = 88;\r\n        channel[j++] = sample / 32767;\r\n      } else {\r\n        if (lastByte < 0) {\r\n          if (i >= dv.byteLength) break;\r\n          lastByte = dv.getUint8(i);\r\n          i += 1;\r\n          code = lastByte & 0xf;\r\n        } else {\r\n          code = (lastByte >> 4) & 0xf;\r\n          lastByte = -1;\r\n        }\r\n        step = ADPCM_STEPS[index];\r\n        delta = 0;\r\n        if (code & 4) delta += step;\r\n        if (code & 2) delta += step >> 1;\r\n        if (code & 1) delta += step >> 2;\r\n        delta += step >> 3;\r\n        index += ADPCM_INDEX[code];\r\n        if (index > 88) index = 88;\r\n        if (index < 0) index = 0;\r\n        sample += code & 8 ? -delta : delta;\r\n        if (sample > 32767) sample = 32767;\r\n        if (sample < -32768) sample = -32768;\r\n        channel[j++] = sample / 32768;\r\n      }\r\n    }\r\n    return Promise.resolve(buffer);\r\n  }\r\n  return Promise.reject(new Error(`Unrecognized WAV format ${format}`));\r\n}\r\n\r\nexport function isWavData(arrayBuffer) {\r\n  const dataView = new DataView(arrayBuffer);\r\n  return (\r\n    dataView.getUint32(0) === 0x52494646 && dataView.getUint32(8) === 0x57415645\r\n  );\r\n}\r\n\r\nexport function isADPCMData(arrayBuffer) {\r\n  const dataView = new DataView(arrayBuffer);\r\n  const format = dataView.getUint16(20, true);\r\n  return isWavData(arrayBuffer) && format === 17;\r\n}\r\n","import decodeADPCMAudio, { isADPCMData } from \"./lib/decode-adpcm-audio.js\";\r\n\r\nexport default class Sound {\r\n  constructor(name, url) {\r\n    this.name = name;\r\n    this.url = url;\r\n\r\n    this.audioBuffer = null;\r\n    this.source = null;\r\n    this.playbackRate = 1;\r\n\r\n    // TODO: Remove this line; initiate downloads from somewhere else instead.\r\n    this.downloadMyAudioBuffer();\r\n  }\r\n\r\n  get duration() {\r\n    return this.audioBuffer.duration;\r\n  }\r\n\r\n  *start() {\r\n    let started = false;\r\n    let isLatestCallToStart = true;\r\n\r\n    if (this._markDone) {\r\n      this._markDone();\r\n    }\r\n\r\n    if (this.audioBuffer) {\r\n      this.playMyAudioBuffer();\r\n      started = true;\r\n    } else {\r\n      // It's possible that start() will be called again before this start()\r\n      // has successfully started the sound (i.e. because it was waiting for\r\n      // the audio buffer to download). If that's the case, _doneDownloading\r\n      // will already exist. We never want to return from start() before the\r\n      // sound has begun playing, but in the case of playUntilDone(), only the\r\n      // latest call should wait for the sound to finish playing; also, we only\r\n      // need to run playMyAudioBuffer once. To meet all these conditions, and\r\n      // also to avoid implementing some kind of addEventListener-esque system,\r\n      // we implement a simple \"listener chain\" here. Every time we set call\r\n      // start(), we keep track of the previous value of doneDownloading, and\r\n      // replace it with a new function. When this function is called directly\r\n      // as a result of the download finishing, it will call, if existent, the\r\n      // previous value of doneDownloading with a flag indicating it is being\r\n      // called from a more recent call to start(). That function will in turn\r\n      // do the same for its saved previous value, and so on, until all the\r\n      // previous values of doneDownloading have been called. Thus, all\r\n      // previous calls of start() will then finish, returning their value of\r\n      // isLatestCallToStart: false, indicating that if the call came from\r\n      // playUntilDone(), that playUntilDone should not wait for the sound to\r\n      // finish playing. Of course, the latest call returns true, and so the\r\n      // containing playUntilDone() (if present) knows to wait.\r\n      const oldDoneDownloading = this._doneDownloading;\r\n      this._doneDownloading = fromMoreRecentCall => {\r\n        if (fromMoreRecentCall) {\r\n          isLatestCallToStart = false;\r\n        } else {\r\n          this.playMyAudioBuffer();\r\n          started = true;\r\n          delete this._doneDownloading;\r\n        }\r\n        if (oldDoneDownloading) {\r\n          oldDoneDownloading(true);\r\n        }\r\n      };\r\n    }\r\n\r\n    while (!started && isLatestCallToStart) yield;\r\n\r\n    return isLatestCallToStart;\r\n  }\r\n\r\n  *playUntilDone() {\r\n    let playing = true;\r\n\r\n    const isLatestCallToStart = yield* this.start();\r\n\r\n    // If we failed to download the audio buffer, just stop here - the sound will\r\n    // never play, so it doesn't make sense to wait for it.\r\n    if (!this.audioBuffer) {\r\n      return;\r\n    }\r\n\r\n    this.source.addEventListener(\"ended\", () => {\r\n      playing = false;\r\n      delete this._markDone;\r\n    });\r\n\r\n    // If there was another call to start() since ours, don't wait for the\r\n    // sound to finish before returning.\r\n    if (!isLatestCallToStart) {\r\n      return;\r\n    }\r\n\r\n    // Set _markDone after calling start(), because start() will call the existing\r\n    // value of _markDone if it's already set. It does this because playUntilDone()\r\n    // is meant to be interrupted if another start() is ran while it's playing.\r\n    // Of course, we don't want *this* playUntilDone() to be treated as though it\r\n    // were interrupted when we call start(), so setting _markDone comes after.\r\n    this._markDone = () => {\r\n      playing = false;\r\n      delete this._markDone;\r\n    };\r\n\r\n    while (playing) yield;\r\n  }\r\n\r\n  stop() {\r\n    if (this._markDone) {\r\n      this._markDone();\r\n    }\r\n\r\n    if (this.source) {\r\n      this.source.disconnect();\r\n      this.source = null;\r\n    }\r\n  }\r\n\r\n  downloadMyAudioBuffer() {\r\n    return fetch(this.url)\r\n      .then(body => body.arrayBuffer())\r\n      .then(arrayBuffer => {\r\n        if (isADPCMData(arrayBuffer)) {\r\n          return decodeADPCMAudio(arrayBuffer, Sound.audioContext).catch(\r\n            error => {\r\n              console.warn(\r\n                `Failed to load sound \"${this.name}\" - will not play:\\n` + error\r\n              );\r\n              return null;\r\n            }\r\n          );\r\n        } else {\r\n          return new Promise((resolve, reject) => {\r\n            Sound.audioContext.decodeAudioData(arrayBuffer, resolve, reject);\r\n          });\r\n        }\r\n      })\r\n      .then(audioBuffer => {\r\n        this.audioBuffer = audioBuffer;\r\n        if (this._doneDownloading) {\r\n          this._doneDownloading();\r\n        }\r\n        return audioBuffer;\r\n      });\r\n  }\r\n\r\n  playMyAudioBuffer() {\r\n    if (!this.audioBuffer) {\r\n      return;\r\n    }\r\n\r\n    if (this.source) {\r\n      this.source.disconnect();\r\n    }\r\n\r\n    this.source = Sound.audioContext.createBufferSource();\r\n    this.source.buffer = this.audioBuffer;\r\n    this.source.playbackRate.value = this.playbackRate;\r\n\r\n    if (this.target) {\r\n      this.source.connect(this.target);\r\n    }\r\n\r\n    this.source.start(Sound.audioContext.currentTime);\r\n  }\r\n\r\n  connect(target) {\r\n    if (target !== this.target) {\r\n      this.target = target;\r\n      if (this.source) {\r\n        this.source.disconnect();\r\n        this.source.connect(this.target);\r\n      }\r\n    }\r\n  }\r\n\r\n  setPlaybackRate(value) {\r\n    this.playbackRate = value;\r\n    if (this.source) {\r\n      this.source.playbackRate.value = value;\r\n    }\r\n  }\r\n\r\n  isConnectedTo(target) {\r\n    return this.target === target;\r\n  }\r\n\r\n  // Note: \"this\" refers to the Sound class in static functions.\r\n\r\n  static get audioContext() {\r\n    this._setupAudioContext();\r\n    return this._audioContext;\r\n  }\r\n\r\n  static _setupAudioContext() {\r\n    if (!this._audioContext) {\r\n      const AudioContext = window.AudioContext || window.webkitAudioContext;\r\n      this._audioContext = new AudioContext();\r\n    }\r\n  }\r\n\r\n  static decodeADPCMAudio(audioBuffer) {\r\n    return decodeADPCMAudio(audioBuffer, this.audioContext);\r\n  }\r\n}\r\n\r\nexport class EffectChain {\r\n  // The code in this class is functionally comparable to the class of the same\r\n  // name in the scratch-audio library, but is completely rewritten and follows\r\n  // somewhat different logic. Still, the class exists on the same principle:\r\n  // a portable way to store the effect chain, independent of the audio sources\r\n  // it affects.\r\n\r\n  constructor(config) {\r\n    const { getNonPatchSoundList } = config;\r\n    this.config = config;\r\n\r\n    this.inputNode = Sound.audioContext.createGain();\r\n\r\n    // This is a mapping of an effect's name to an object containing all the\r\n    // nodes which are of use to that effect: always an {input, output} pair,\r\n    // as well as any other nodes of use to that effect. The values here are\r\n    // filled in by an effect descriptor's makeNodes() function, and may\r\n    // contain duplicate copies of the same node within a particular effect's\r\n    // object, when that's of use to make the logic clearer (e.g. when there's\r\n    // no distinction between the input and output node, or referring to the\r\n    // output node by a more specific name).\r\n    this.effectNodes = {};\r\n\r\n    this.resetToInitial();\r\n\r\n    this.getNonPatchSoundList = getNonPatchSoundList;\r\n  }\r\n\r\n  resetToInitial() {\r\n    // Note: some effects won't be reset by this function, except for when they\r\n    // are set for the first time (i.e. when the EffectChain is instantiated).\r\n    // Look for the \"reset: false\" flag in the effect descriptor list.\r\n\r\n    const initials = EffectChain.getInitialEffectValues();\r\n    if (this.effectValues) {\r\n      for (const [name, initialValue] of Object.entries(\r\n        EffectChain.getInitialEffectValues()\r\n      )) {\r\n        if (EffectChain.getEffectDescriptor(name).reset !== false) {\r\n          this.setEffectValue(name, initialValue);\r\n        }\r\n      }\r\n    } else {\r\n      this.effectValues = initials;\r\n    }\r\n  }\r\n\r\n  updateAudioEffect(name) {\r\n    const descriptor = EffectChain.getEffectDescriptor(name);\r\n\r\n    if (!descriptor) {\r\n      return;\r\n    }\r\n\r\n    // updateAudioEffect doesn't take a value - it only reflects the existing\r\n    // value in the actual effects applied to nodes and sounds!\r\n    const value = this.effectValues[name];\r\n\r\n    if (descriptor.isPatch) {\r\n      // Here, we search for the next and previous effects in the chain\r\n      // who have existent nodes. This means we'll skip non-patch effects as\r\n      // well as effects are set to their initial value.\r\n\r\n      let next = descriptor;\r\n      do {\r\n        next = EffectChain.getNextEffectDescriptor(next.name);\r\n      } while (next && !this.effectNodes[next.name]);\r\n\r\n      let previous = descriptor;\r\n      do {\r\n        previous = EffectChain.getPreviousEffectDescriptor(previous.name);\r\n      } while (previous && !this.effectNodes[previous.name]);\r\n\r\n      // If we have previous and next values available, they'll currently be\r\n      // the corresponding descriptors. But we only ever need to access the\r\n      // nodes which correspond to those descriptor's names, so we replace them\r\n      // with the actual objects containing the effect's nodes here to simplify\r\n      // later code.\r\n\r\n      if (next) {\r\n        next = this.effectNodes[next.name];\r\n      }\r\n\r\n      if (previous) {\r\n        next = this.effectNodes[previous.name];\r\n      }\r\n\r\n      // If there is no preceding or following effect which has existent nodes,\r\n      // we'll make the variables reference the target input and target nodes\r\n      // of the EffectChain - i.e, the two ends of the chain, as far as this\r\n      // class is concerned. (Note that while the input node will always be\r\n      // present, because it's defined right on the EffectChain, it's possible\r\n      // that there won't be any target node, leaving the value for \"next\"\r\n      // still null.)\r\n      //\r\n      // We do need to keep to the structure that effectNodes contains, though.\r\n      // When we access the previous node (or the EffectChain's input node, in\r\n      // this case), we'll be making a connection with its output; likewise,\r\n      // when we're accessing the next node (or the EffectChain's target),\r\n      // we'll be connecting something to its input. That's reflected in the\r\n      // values here.\r\n\r\n      if (!previous) {\r\n        previous = { output: this.inputNode };\r\n      }\r\n\r\n      if (!next && this.target) {\r\n        next = { input: this.target };\r\n      }\r\n\r\n      // \"Patch\" effects are applied by sending audio data through an ordered\r\n      // series - i.e, a chain - of WebAudio nodes. All effects have an input\r\n      // node and an output node; for simple effects, these may actually be the\r\n      // same node. (Take a look at the volume effect, which uses a single Gain\r\n      // node as both its input and output.) Other effects are more complex.\r\n      // The code in this block controls the actual chaining behavior of\r\n      // EffectChain, assuring that all effects form a clean chain.\r\n      let nodes = this.effectNodes[descriptor.name];\r\n      if (!nodes && value !== descriptor.initial) {\r\n        nodes = descriptor.makeNodes();\r\n        this.effectNodes[descriptor.name] = nodes;\r\n\r\n        // Connect the previous effect, or, if there is none, the EffectChain\r\n        // input, to this effect. Also disconnect it from whatever it was\r\n        // previously connected to, so we aren't sending data more than one\r\n        // place at a time - that would mess with the chain.\r\n        previous.output.disconnect();\r\n        previous.output.connect(nodes.input);\r\n\r\n        // Connect this effect to the next effect, or, if there is none,\r\n        // the EffectChain target.\r\n        if (next) {\r\n          nodes.output.connect(next.input);\r\n        }\r\n      }\r\n\r\n      if (value === descriptor.initial) {\r\n        // If we're setting to the initial value, disconnect and discard the\r\n        // effect's nodes. It's not necessary to keep nodes that don't cause\r\n        // an effect in the chain. (We don't need to run the set() behavior\r\n        // specified on the effect descriptor, since we're disconnecting and\r\n        // discarding the nodes - the only values that function has access to.)\r\n        if (nodes) {\r\n          // There's no need to define custom disposal behavior per effect,\r\n          // since it's always a matter of simply disconnecting every node.\r\n          // The disconnect() method of a WebAudio node won't error if it's\r\n          // already had all its connections removed, but we avoid redundant\r\n          // calls here anyway.\r\n          for (const node of new Set(Object.values(nodes))) {\r\n            node.disconnect();\r\n          }\r\n\r\n          // We also need to establish a connection between the adjacent nodes\r\n          // (which may be the EffectChain's input node and target node, if\r\n          // there aren't any adjacent effect nodes).\r\n          if (next) {\r\n            previous.output.connect(next.input);\r\n          }\r\n\r\n          // Finally, we discard the object which holds the effect's nodes.\r\n          // We aren't going to be using it anymore, and we need it gone so\r\n          // that we recreate the nodes and correctly position them back in\r\n          // the chain, if we use this effect again later.\r\n          delete this.effectNodes[name];\r\n        }\r\n      } else {\r\n        descriptor.set(value, nodes);\r\n      }\r\n    } else {\r\n      // Non-\"patch\" effects operate directly on Sound objects, accessing\r\n      // APIs provided by that class. The actual sound list is provided by the\r\n      // caller of EffectChain.\r\n      for (const sound of this.getNonPatchSoundList()) {\r\n        descriptor.set(value, sound);\r\n      }\r\n    }\r\n  }\r\n\r\n  connect(target) {\r\n    this.target = target;\r\n\r\n    // All the code here is basically the same as what's written in\r\n    // updateAudioEffect above; specific to this function, we want to\r\n    // disconnect the final output in the chain - which may be the input\r\n    // node - and then connect it to the newly specified target.\r\n\r\n    let last = EffectChain.getLastEffectDescriptor();\r\n    do {\r\n      last = EffectChain.getPreviousEffectDescriptor(last.name);\r\n    } while (last && !this.effectNodes[last.name]);\r\n\r\n    if (last) {\r\n      last = this.effectNodes[last.name];\r\n    } else {\r\n      last = { output: this.inputNode };\r\n    }\r\n\r\n    last.output.disconnect();\r\n    last.output.connect(target);\r\n  }\r\n\r\n  setEffectValue(name, value) {\r\n    value = Number(value);\r\n    if (\r\n      name in this.effectValues &&\r\n      !isNaN(value) &&\r\n      value !== this.effectValues[name]\r\n    ) {\r\n      this.effectValues[name] = value;\r\n      this.clampEffectValue(name);\r\n      this.updateAudioEffect(name);\r\n    }\r\n  }\r\n\r\n  changeEffectValue(name, value) {\r\n    value = Number(value);\r\n    if (name in this.effectValues && !isNaN(value) && value !== 0) {\r\n      this.effectValues[name] += value;\r\n      this.clampEffectValue(name);\r\n      this.updateAudioEffect(name);\r\n    }\r\n  }\r\n\r\n  clampEffectValue(name) {\r\n    // Not all effects are clamped (pitch, for example); it's also possible to\r\n    // specify only a minimum or maximum bound, instead of both.\r\n    const descriptor = EffectChain.getEffectDescriptor(name);\r\n    let value = this.effectValues[name];\r\n    if (\"minimum\" in descriptor && value < descriptor.minimum) {\r\n      value = descriptor.minimum;\r\n    } else if (\"maximum\" in descriptor && value > descriptor.maximum) {\r\n      value = descriptor.maximum;\r\n    }\r\n    this.effectValues[name] = value;\r\n  }\r\n\r\n  getEffectValue(name) {\r\n    return this.effectValues[name] || 0;\r\n  }\r\n\r\n  clone(newConfig) {\r\n    const newEffectChain = new EffectChain(\r\n      Object.assign({}, this.config, newConfig)\r\n    );\r\n\r\n    for (const [name, value] of Object.entries(this.effectValues)) {\r\n      const descriptor = EffectChain.getEffectDescriptor(name);\r\n      if (!descriptor.resetOnClone) {\r\n        newEffectChain.setEffectValue(name, value);\r\n      }\r\n    }\r\n\r\n    newEffectChain.connect(this.target);\r\n\r\n    return newEffectChain;\r\n  }\r\n\r\n  applyToSound(sound) {\r\n    sound.connect(this.inputNode);\r\n\r\n    for (const [name, value] of Object.entries(this.effectValues)) {\r\n      const descriptor = EffectChain.getEffectDescriptor(name);\r\n      if (!descriptor.isPatch) {\r\n        descriptor.set(value, sound);\r\n      }\r\n    }\r\n  }\r\n\r\n  isTargetOf(sound) {\r\n    return sound.isConnectedTo(this.inputNode);\r\n  }\r\n\r\n  static getInitialEffectValues() {\r\n    // This would be an excellent place to use Object.fromEntries, but that\r\n    // function has been implemented in only the latest of a few modern\r\n    // browsers. :P\r\n    const initials = {};\r\n    for (const { name, initial } of this.effectDescriptors) {\r\n      initials[name] = initial;\r\n    }\r\n    return initials;\r\n  }\r\n\r\n  static getEffectDescriptor(name) {\r\n    return this.effectDescriptors.find(descriptor => descriptor.name === name);\r\n  }\r\n\r\n  static getFirstEffectDescriptor() {\r\n    return this.effectDescriptors[0];\r\n  }\r\n\r\n  static getLastEffectDescriptor() {\r\n    return this.effectDescriptors[this.effectDescriptors.length - 1];\r\n  }\r\n\r\n  static getNextEffectDescriptor(name) {\r\n    // .find() provides three values to its passed function: the value of the\r\n    // current item, that item's index, and the array on which .find() is\r\n    // operating. In this case, we're only concerned with the index.\r\n    // For each item in the list, besides the first, we check if the item\r\n    // before it matches the name we were given. By initially shifting all the\r\n    // descriptors using slice(1), the index of any item in the shifted list\r\n    // corresponds to the previous item in the original list. Thus, if that\r\n    // previous item matches the provided name, by definition, we'll have found\r\n    // the item which comes after it.\r\n    return this.effectDescriptors\r\n      .slice(1)\r\n      .find((_, i) => this.effectDescriptors[i].name === name);\r\n  }\r\n\r\n  static getPreviousEffectDescriptor(name) {\r\n    // This function's a little simpler, since it doesn't involve shifting the\r\n    // list. We still use slice(), but this time simply to cut off the last\r\n    // item; that item will never come before any other, after all. We search\r\n    // the list for the item whose following item matches the provided name,\r\n    // using the more typical [i + 1] way of accessing an adjacent item.\r\n    // (In getNextEffectDescriptor(), we don't need to offset the index like\r\n    // that, because the shift already lines up the index as we need it.)\r\n    return this.effectDescriptors\r\n      .slice(0, -1)\r\n      .find((_, i) => this.effectDescriptors[i + 1].name === name);\r\n  }\r\n}\r\n\r\n// These are constant values which can be affected to tweak the way effects\r\n// are applied. They match the values used in Scratch 3.0.\r\nEffectChain.decayDuration = 0.025;\r\nEffectChain.decayWait = 0.05;\r\n\r\n// Instead of creating a basic Effect class and then implementing a subclass\r\n// for each effect type, we use a simplified object-descriptor style.\r\n// The makeNodes() function returns an object which is passed on to set(), so\r\n// that effects are able to access a variety of nodes (or other values, if\r\n// necessary) required to execute the desired effect.\r\n//\r\n// The code in makeNodes as well as the general definition for each effect is\r\n// all graciously based on LLK's scratch-audio library.\r\n//\r\n// The initial value of an effect should always be the value at which the\r\n// sound is not affected at all - i.e, it would be the same if the effect\r\n// nodes were completely disconnected from the chain or otherwise had never\r\n// been applied. This allows for clean discarding of effect nodes when returned\r\n// to the initial value.\r\n//\r\n// The order of this array matches AudioEngine's effects list in scratch-audio.\r\n// Earlier in the list is closer to the EffectChain input node; later is closer\r\n// to its target (output). Note that a non-\"patch\" effect's position in the\r\n// array has no bearing on effect behavior, since it isn't part of the chain\r\n// system.\r\n//\r\n// Note that this descriptor list is fairly easy to build on, if we'd like to\r\n// add more audio effects in the future. (Scratch used to have more, but they\r\n// were removed - see commit ff6cd4a - because they depended on an external\r\n// library and were too processor-intensive to support on some devices.)\r\nEffectChain.effectDescriptors = [\r\n  {\r\n    name: \"pan\",\r\n    initial: 0,\r\n    minimum: -100,\r\n    maximum: 100,\r\n    isPatch: true,\r\n    makeNodes() {\r\n      const aCtx = Sound.audioContext;\r\n      const input = aCtx.createGain();\r\n      const leftGain = aCtx.createGain();\r\n      const rightGain = aCtx.createGain();\r\n      const channelMerger = aCtx.createChannelMerger(2);\r\n      const output = channelMerger;\r\n      input.connect(leftGain);\r\n      input.connect(rightGain);\r\n      leftGain.connect(channelMerger, 0, 0);\r\n      rightGain.connect(channelMerger, 0, 1);\r\n      return { input, output, leftGain, rightGain, channelMerger };\r\n    },\r\n    set(value, { input, output, leftGain, rightGain }) {\r\n      const p = (value + 100) / 200;\r\n      const leftVal = Math.cos((p * Math.PI) / 2);\r\n      const rightVal = Math.sin((p * Math.PI) / 2);\r\n      const { currentTime } = Sound.audioContext;\r\n      const { decayWait, decayDuration } = EffectChain;\r\n      leftGain.gain.setTargetAtTime(\r\n        leftVal,\r\n        currentTime + decayWait,\r\n        decayDuration\r\n      );\r\n      rightGain.gain.setTargetAtTime(\r\n        rightVal,\r\n        currentTime + decayWait,\r\n        decayDuration\r\n      );\r\n    }\r\n  },\r\n  {\r\n    name: \"pitch\",\r\n    initial: 0,\r\n    isPatch: false,\r\n    set(value, sound) {\r\n      const interval = value / 10;\r\n      const ratio = Math.pow(2, interval / 12);\r\n      sound.setPlaybackRate(ratio);\r\n    }\r\n  },\r\n  {\r\n    name: \"volume\",\r\n    initial: 100,\r\n    minimum: 0,\r\n    maximum: 100,\r\n    resetOnStart: false,\r\n    resetOnClone: true,\r\n    isPatch: true,\r\n    makeNodes() {\r\n      const node = Sound.audioContext.createGain();\r\n      return {\r\n        input: node,\r\n        output: node,\r\n        node\r\n      };\r\n    },\r\n    set(value, { node }) {\r\n      node.gain.linearRampToValueAtTime(\r\n        value / 100,\r\n        Sound.audioContext.currentTime + EffectChain.decayDuration\r\n      );\r\n    }\r\n  }\r\n];\r\n\r\nexport class AudioEffectMap {\r\n  // This class provides a simple interface for setting and getting audio\r\n  // effects stored on an EffectChain, similar to EffectMap (that class being\r\n  // for graphic effects). It takes an EffectChain and automatically generates\r\n  // properties according to the names of the effect descriptors, acting with\r\n  // the EffectChain's API when accessed.\r\n\r\n  constructor(effectChain) {\r\n    this.effectChain = effectChain;\r\n\r\n    for (const { name } of EffectChain.effectDescriptors) {\r\n      Object.defineProperty(this, name, {\r\n        get: () => effectChain.getEffectValue(name),\r\n        set: value => effectChain.setEffectValue(name, value)\r\n      });\r\n    }\r\n  }\r\n\r\n  clear() {\r\n    this.effectChain.resetToInitial();\r\n  }\r\n}\r\n","import Color from \"./Color.js\";\r\nimport Trigger from \"./Trigger.js\";\r\nimport Sound, { EffectChain, AudioEffectMap } from \"./Sound.js\";\r\n\r\nimport { effectNames } from \"./renderer/effectInfo.js\";\r\n// This is a wrapper to allow the enabled effects in a sprite to be used as a Map key.\r\n// By setting an effect, the bitmask is updated as well.\r\n// This allows the bitmask to be used to uniquely identify a set of enabled effects.\r\nclass _EffectMap {\r\n  constructor() {\r\n    this._bitmask = 0;\r\n    this._effectValues = {};\r\n\r\n    for (let i = 0; i < effectNames.length; i++) {\r\n      const effectName = effectNames[i];\r\n      this._effectValues[effectName] = 0;\r\n\r\n      Object.defineProperty(this, effectName, {\r\n        get: () => {\r\n          return this._effectValues[effectName];\r\n        },\r\n\r\n        set: val => {\r\n          this._effectValues[effectName] = val;\r\n\r\n          if (val === 0) {\r\n            // If the effect value is 0, meaning it's disabled, set its bit in the bitmask to 0.\r\n            this._bitmask = this._bitmask & ~(1 << i);\r\n          } else {\r\n            // Otherwise, set its bit to 1.\r\n            this._bitmask = this._bitmask | (1 << i);\r\n          }\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  _clone() {\r\n    const m = new _EffectMap();\r\n    for (const effectName of Object.keys(this._effectValues)) {\r\n      m[effectName] = this[effectName];\r\n    }\r\n    return m;\r\n  }\r\n\r\n  clear() {\r\n    for (const effectName of Object.keys(this._effectValues)) {\r\n      this._effectValues[effectName] = 0;\r\n    }\r\n    this._bitmask = 0;\r\n  }\r\n}\r\n\r\nclass SpriteBase {\r\n  constructor(initialConditions, vars = {}) {\r\n    this._project = null;\r\n\r\n    const { costumeNumber, layerOrder = 0 } = initialConditions;\r\n    this._costumeNumber = costumeNumber;\r\n    this._layerOrder = layerOrder;\r\n\r\n    this.triggers = [];\r\n    this.watchers = {};\r\n    this.costumes = [];\r\n    this.sounds = [];\r\n\r\n    this.effectChain = new EffectChain({\r\n      getNonPatchSoundList: this.getSoundsPlayedByMe.bind(this)\r\n    });\r\n    this.effectChain.connect(Sound.audioContext.destination);\r\n\r\n    this.effects = new _EffectMap();\r\n    this.audioEffects = new AudioEffectMap(this.effectChain);\r\n\r\n    this._vars = vars;\r\n  }\r\n\r\n  getSoundsPlayedByMe() {\r\n    return this.sounds.filter(sound => this.effectChain.isTargetOf(sound));\r\n  }\r\n\r\n  get stage() {\r\n    return this._project.stage;\r\n  }\r\n\r\n  get sprites() {\r\n    return this._project.sprites;\r\n  }\r\n\r\n  get vars() {\r\n    return this._vars;\r\n  }\r\n\r\n  get costumeNumber() {\r\n    return this._costumeNumber;\r\n  }\r\n\r\n  set costumeNumber(number) {\r\n    this._costumeNumber = ((number - 1) % this.costumes.length) + 1;\r\n  }\r\n\r\n  set costume(costume) {\r\n    if (typeof costume === \"number\") {\r\n      this.costumeNumber = costume;\r\n    }\r\n    if (typeof costume === \"string\") {\r\n      const index = this.costumes.findIndex(c => c.name === costume);\r\n      if (index > -1) {\r\n        this.costumeNumber = index + 1;\r\n      } else {\r\n        switch (costume) {\r\n          case \"next costume\":\r\n          case \"next backdrop\": {\r\n            this.costumeNumber = this.costumeNumber + 1;\r\n            break;\r\n          }\r\n\r\n          case \"previous costume\":\r\n          case \"previous backdrop\": {\r\n            this.costumeNumber = this.costumeNumber - 1;\r\n            break;\r\n          }\r\n\r\n          case \"random costume\":\r\n          case \"random backdrop\": {\r\n            // Based on joker314's inclusiveRandIntWithout: https://github.com/LLK/scratch-vm/pull/2011\r\n            // Note: We use 1 -> length instead of 0 -> length-1, since we want a 1-indexed result.\r\n            const lower = 1;\r\n            const upper = this.costumes.length;\r\n            const excluded = this.costumeNumber;\r\n\r\n            const possibleOptions = upper - lower;\r\n            let randInt = lower + Math.floor(Math.random() * possibleOptions);\r\n            if (randInt >= excluded) {\r\n              randInt++;\r\n            }\r\n\r\n            this.costumeNumber = randInt;\r\n            break;\r\n          }\r\n\r\n          default: {\r\n            if (!(isNaN(costume) || costume.trim().length === 0)) {\r\n              this.costumeNumber = Number(costume);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  get costume() {\r\n    return this.costumes[this.costumeNumber - 1];\r\n  }\r\n\r\n  moveAhead(value = Infinity) {\r\n    if (typeof value === \"number\") {\r\n      this._project.changeSpriteLayer(this, value);\r\n    } else {\r\n      this._project.changeSpriteLayer(this, 1, value);\r\n    }\r\n  }\r\n\r\n  moveBehind(value = Infinity) {\r\n    if (typeof value === \"number\") {\r\n      this._project.changeSpriteLayer(this, -value);\r\n    } else {\r\n      this._project.changeSpriteLayer(this, -1, value);\r\n    }\r\n  }\r\n\r\n  degToRad(deg) {\r\n    return (deg * Math.PI) / 180;\r\n  }\r\n\r\n  radToDeg(rad) {\r\n    return (rad * 180) / Math.PI;\r\n  }\r\n\r\n  degToScratch(deg) {\r\n    return -deg + 90;\r\n  }\r\n\r\n  scratchToDeg(scratchDir) {\r\n    return -scratchDir + 90;\r\n  }\r\n\r\n  radToScratch(rad) {\r\n    return this.degToScratch(this.radToDeg(rad));\r\n  }\r\n\r\n  scratchToRad(scratchDir) {\r\n    return this.degToRad(this.scratchToDeg(scratchDir));\r\n  }\r\n\r\n  // Wrap rotation from -180 to 180.\r\n  normalizeDeg(deg) {\r\n    // This is a pretty big math expression, but it's necessary because in JavaScript,\r\n    // the % operator means \"remainder\", not \"modulo\", and so negative numbers won't \"wrap around\".\r\n    // See https://web.archive.org/web/20090717035140if_/javascript.about.com/od/problemsolving/a/modulobug.htm\r\n    return ((((deg + 180) % 360) + 360) % 360) - 180;\r\n  }\r\n\r\n  // Given a generator function, return a version of it that runs in \"warp mode\" (no yields).\r\n  warp(procedure) {\r\n    const bound = procedure.bind(this);\r\n    return (...args) => {\r\n      const inst = bound(...args);\r\n      while (!inst.next().done);\r\n    };\r\n  }\r\n\r\n  random(a, b) {\r\n    const min = Math.min(a, b);\r\n    const max = Math.max(a, b);\r\n    if (min % 1 === 0 && max % 1 === 0) {\r\n      return Math.floor(Math.random() * (max - min + 1)) + min;\r\n    }\r\n    return Math.random() * (max - min) + min;\r\n  }\r\n\r\n  *wait(secs) {\r\n    let endTime = new Date();\r\n    endTime.setMilliseconds(endTime.getMilliseconds() + secs * 1000);\r\n    while (new Date() < endTime) {\r\n      yield;\r\n    }\r\n  }\r\n\r\n  get mouse() {\r\n    return this._project.input.mouse;\r\n  }\r\n\r\n  keyPressed(name) {\r\n    return this._project.input.keyPressed(name);\r\n  }\r\n\r\n  get timer() {\r\n    const ms = new Date() - this._project.timerStart;\r\n    return ms / 1000;\r\n  }\r\n\r\n  restartTimer() {\r\n    this._project.restartTimer();\r\n  }\r\n\r\n  *startSound(soundName) {\r\n    const sound = this.getSound(soundName);\r\n    if (sound) {\r\n      this.effectChain.applyToSound(sound);\r\n      yield* sound.start();\r\n    }\r\n  }\r\n\r\n  *playSoundUntilDone(soundName) {\r\n    const sound = this.getSound(soundName);\r\n    if (sound) {\r\n      sound.connect(this.effectChain.inputNode);\r\n      this.effectChain.applyToSound(sound);\r\n      yield* sound.playUntilDone();\r\n    }\r\n  }\r\n\r\n  getSound(soundName) {\r\n    if (typeof soundName === \"number\") {\r\n      return this.sounds[(soundName - 1) % this.sounds.length];\r\n    } else {\r\n      return this.sounds.find(s => s.name === soundName);\r\n    }\r\n  }\r\n\r\n  stopAllSounds() {\r\n    this._project.stopAllSounds();\r\n  }\r\n\r\n  stopAllOfMySounds() {\r\n    for (const sound of this.sounds) {\r\n      sound.stop();\r\n    }\r\n  }\r\n\r\n  broadcast(name) {\r\n    return this._project.fireTrigger(Trigger.BROADCAST, { name });\r\n  }\r\n\r\n  *broadcastAndWait(name) {\r\n    let running = true;\r\n    this.broadcast(name).then(() => {\r\n      running = false;\r\n    });\r\n\r\n    while (running) {\r\n      yield;\r\n    }\r\n  }\r\n\r\n  clearPen() {\r\n    this._project.renderer.clearPen();\r\n  }\r\n\r\n  *askAndWait(question) {\r\n    if (this._speechBubble) {\r\n      this.say(null);\r\n    }\r\n\r\n    let done = false;\r\n    this._project.askAndWait(question).then(() => {\r\n      done = true;\r\n    });\r\n\r\n    while (!done) yield;\r\n  }\r\n\r\n  get answer() {\r\n    return this._project.answer;\r\n  }\r\n}\r\n\r\nexport class Sprite extends SpriteBase {\r\n  constructor(initialConditions, ...args) {\r\n    super(initialConditions, ...args);\r\n\r\n    const {\r\n      x,\r\n      y,\r\n      direction,\r\n      rotationStyle,\r\n      costumeNumber,\r\n      size,\r\n      visible,\r\n      penDown,\r\n      penSize,\r\n      penColor\r\n    } = initialConditions;\r\n\r\n    this._x = x;\r\n    this._y = y;\r\n    this._direction = direction;\r\n    this.rotationStyle = rotationStyle || Sprite.RotationStyle.ALL_AROUND;\r\n    this._costumeNumber = costumeNumber;\r\n    this.size = size;\r\n    this.visible = visible;\r\n\r\n    this.parent = null;\r\n    this.clones = [];\r\n\r\n    this._penDown = penDown || false;\r\n    this.penSize = penSize || 1;\r\n    this._penColor = penColor || Color.rgb(0, 0, 0);\r\n\r\n    this._speechBubble = {\r\n      text: \"\",\r\n      style: \"say\",\r\n      timeout: null\r\n    };\r\n  }\r\n\r\n  createClone() {\r\n    const clone = Object.assign(\r\n      Object.create(Object.getPrototypeOf(this)),\r\n      this\r\n    );\r\n\r\n    clone._project = this._project;\r\n    clone.triggers = this.triggers.map(\r\n      trigger => new Trigger(trigger.trigger, trigger.options, trigger._script)\r\n    );\r\n    clone.costumes = this.costumes;\r\n    clone.sounds = this.sounds;\r\n    clone._vars = Object.assign({}, this._vars);\r\n\r\n    clone._speechBubble = {\r\n      text: \"\",\r\n      style: \"say\",\r\n      timeout: null\r\n    };\r\n\r\n    clone.effects = this.effects._clone();\r\n\r\n    // Clones inherit audio effects from the original sprite, for some reason.\r\n    // Couldn't explain it, but that's the behavior in Scratch 3.0.\r\n    let original = this;\r\n    while (original.parent) {\r\n      original = original.parent;\r\n    }\r\n    clone.effectChain = original.effectChain.clone({\r\n      getNonPatchSoundList: clone.getSoundsPlayedByMe.bind(clone)\r\n    });\r\n\r\n    // Make a new audioEffects interface which acts on the cloned effect chain.\r\n    clone.audioEffects = new AudioEffectMap(clone.effectChain);\r\n\r\n    clone.clones = [];\r\n    clone.parent = this;\r\n    this.clones.push(clone);\r\n\r\n    // Trigger CLONE_START:\r\n    const triggers = clone.triggers.filter(tr =>\r\n      tr.matches(Trigger.CLONE_START)\r\n    );\r\n    this._project._startTriggers(\r\n      triggers.map(trigger => ({ trigger, target: clone }))\r\n    );\r\n  }\r\n\r\n  deleteThisClone() {\r\n    if (this.parent === null) return;\r\n\r\n    this.parent.clones = this.parent.clones.filter(clone => clone !== this);\r\n\r\n    this._project.runningTriggers = this._project.runningTriggers.filter(\r\n      ({ target }) => target !== this\r\n    );\r\n  }\r\n\r\n  andClones() {\r\n    return [this, ...this.clones.flatMap(clone => clone.andClones())];\r\n  }\r\n\r\n  get direction() {\r\n    return this._direction;\r\n  }\r\n\r\n  set direction(dir) {\r\n    this._direction = this.normalizeDeg(dir);\r\n  }\r\n\r\n  goto(x, y) {\r\n    if (x === this.x && y === this.y) return;\r\n\r\n    if (this.penDown) {\r\n      this._project.renderer.penLine(\r\n        { x: this._x, y: this._y },\r\n        { x, y },\r\n        this._penColor,\r\n        this.penSize\r\n      );\r\n    }\r\n\r\n    this._x = x;\r\n    this._y = y;\r\n  }\r\n\r\n  get x() {\r\n    return this._x;\r\n  }\r\n\r\n  set x(x) {\r\n    this.goto(x, this._y);\r\n  }\r\n\r\n  get y() {\r\n    return this._y;\r\n  }\r\n\r\n  set y(y) {\r\n    this.goto(this._x, y);\r\n  }\r\n\r\n  move(dist) {\r\n    const moveDir = this.scratchToRad(this.direction);\r\n\r\n    this.goto(\r\n      this._x + dist * Math.cos(moveDir),\r\n      this._y + dist * Math.sin(moveDir)\r\n    );\r\n  }\r\n\r\n  *glide(seconds, x, y) {\r\n    const interpolate = (a, b, t) => a + (b - a) * t;\r\n\r\n    const startTime = new Date();\r\n    const startX = this._x;\r\n    const startY = this._y;\r\n\r\n    let t;\r\n    do {\r\n      t = (new Date() - startTime) / (seconds * 1000);\r\n      this.goto(interpolate(startX, x, t), interpolate(startY, y, t));\r\n      yield;\r\n    } while (t < 1);\r\n  }\r\n\r\n  get penDown() {\r\n    return this._penDown;\r\n  }\r\n\r\n  set penDown(penDown) {\r\n    if (penDown) {\r\n      this._project.renderer.penLine(\r\n        { x: this.x, y: this.y },\r\n        { x: this.x, y: this.y },\r\n        this._penColor,\r\n        this.penSize\r\n      );\r\n    }\r\n    this._penDown = penDown;\r\n  }\r\n\r\n  get penColor() {\r\n    return this._penColor;\r\n  }\r\n\r\n  set penColor(color) {\r\n    if (color instanceof Color) {\r\n      this._penColor = color;\r\n    } else {\r\n      console.error(\r\n        `${color} is not a valid penColor. Try using the Color class!`\r\n      );\r\n    }\r\n  }\r\n\r\n  stamp() {\r\n    this._project.renderer.stamp(this);\r\n  }\r\n\r\n  touching(target, fast = false) {\r\n    if (typeof target === \"string\") {\r\n      switch (target) {\r\n        case \"mouse\":\r\n          return this._project.renderer.checkPointCollision(\r\n            this,\r\n            {\r\n              x: this.mouse.x,\r\n              y: this.mouse.y\r\n            },\r\n            fast\r\n          );\r\n        default:\r\n          console.error(\r\n            `Cannot find target \"${target}\" in \"touching\". Did you mean to pass a sprite class instead?`\r\n          );\r\n          return false;\r\n      }\r\n    } else if (target instanceof Color) {\r\n      return this._project.renderer.checkColorCollision(this, target);\r\n    }\r\n\r\n    return this._project.renderer.checkSpriteCollision(this, target, fast);\r\n  }\r\n\r\n  colorTouching(color, target) {\r\n    if (typeof target === \"string\") {\r\n      console.error(\r\n        `Cannot find target \"${target}\" in \"touchingColor\". Did you mean to pass a sprite class instead?`\r\n      );\r\n      return false;\r\n    }\r\n\r\n    if (typeof color === \"string\") {\r\n      console.error(\r\n        `Cannot find color \"${color}\" in \"touchingColor\". Did you mean to pass a Color instance instead?`\r\n      );\r\n      return false;\r\n    }\r\n\r\n    if (target instanceof Color) {\r\n      // \"Color is touching color\"\r\n      return this._project.renderer.checkColorCollision(this, target, color);\r\n    } else {\r\n      // \"Color is touching sprite\" (not implemented in Scratch!)\r\n      return this._project.renderer.checkSpriteCollision(\r\n        this,\r\n        target,\r\n        false,\r\n        color\r\n      );\r\n    }\r\n  }\r\n\r\n  say(text) {\r\n    clearTimeout(this._speechBubble.timeout);\r\n    this._speechBubble = { text: String(text), style: \"say\", timeout: null };\r\n  }\r\n\r\n  think(text) {\r\n    clearTimeout(this._speechBubble.timeout);\r\n    this._speechBubble = { text: String(text), style: \"think\", timeout: null };\r\n  }\r\n\r\n  *sayAndWait(text, seconds) {\r\n    clearTimeout(this._speechBubble.timeout);\r\n\r\n    let done = false;\r\n    const timeout = setTimeout(() => {\r\n      this._speechBubble.text = \"\";\r\n      this.timeout = null;\r\n      done = true;\r\n    }, seconds * 1000);\r\n\r\n    this._speechBubble = { text, style: \"say\", timeout };\r\n    while (!done) yield;\r\n  }\r\n\r\n  *thinkAndWait(text, seconds) {\r\n    clearTimeout(this._speechBubble.timeout);\r\n\r\n    let done = false;\r\n    const timeout = setTimeout(() => {\r\n      this._speechBubble.text = \"\";\r\n      this.timeout = null;\r\n      done = true;\r\n    }, seconds * 1000);\r\n\r\n    this._speechBubble = { text, style: \"think\", timeout };\r\n    while (!done) yield;\r\n  }\r\n}\r\n\r\nSprite.RotationStyle = Object.freeze({\r\n  ALL_AROUND: Symbol(\"ALL_AROUND\"),\r\n  LEFT_RIGHT: Symbol(\"LEFT_RIGHT\"),\r\n  DONT_ROTATE: Symbol(\"DONT_ROTATE\")\r\n});\r\n\r\nexport class Stage extends SpriteBase {\r\n  constructor(initialConditions, ...args) {\r\n    super(initialConditions, ...args);\r\n\r\n    // Use defineProperties to make these non-writable.\r\n    // Changing the width and height of the stage after initialization isn't supported.\r\n    Object.defineProperties(this, {\r\n      width: {\r\n        value: initialConditions.width || 480,\r\n        enumerable: true\r\n      },\r\n      height: {\r\n        value: initialConditions.height || 360,\r\n        enumerable: true\r\n      }\r\n    });\r\n\r\n    this.name = \"Stage\";\r\n\r\n    // For obsolete counter blocks.\r\n    this.__counter = 0;\r\n  }\r\n}\r\n","import Matrix from \"./renderer/Matrix.js\";\r\nimport PenSkin from \"./renderer/PenSkin.js\";\r\nimport Rectangle from \"./renderer/Rectangle.js\";\r\nimport ShaderManager from \"./renderer/ShaderManager.js\";\r\nimport SkinCache from \"./renderer/SkinCache.js\";\r\nimport { effectBitmasks } from \"./renderer/effectInfo.js\";\r\n\r\nimport { Sprite, Stage } from \"./Sprite.js\";\r\n\r\nexport default class Renderer {\r\n  constructor(project, renderTarget) {\r\n    const w = project.stage.width;\r\n    const h = project.stage.height;\r\n    this.project = project;\r\n    this.stage = this.createStage(w, h);\r\n    this.gl = this.stage.getContext(\"webgl\", { antialias: false });\r\n\r\n    if (renderTarget) {\r\n      this.setRenderTarget(renderTarget);\r\n    } else {\r\n      this.renderTarget = null;\r\n    }\r\n\r\n    this._shaderManager = new ShaderManager(this);\r\n    this._skinCache = new SkinCache(this);\r\n\r\n    this._currentShader = null;\r\n    this._currentFramebuffer = null;\r\n    this._screenSpaceScale = 1;\r\n\r\n    // Initialize a bunch of WebGL state\r\n    const gl = this.gl;\r\n\r\n    // Use premultiplied alpha for proper color blending.\r\n    gl.enable(gl.BLEND);\r\n    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\r\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);\r\n\r\n    // Initialize vertex buffer. This will draw one 2D quadrilateral.\r\n    const buffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\r\n\r\n    // These are 6 points which make up 2 triangles which make up 1 quad/rectangle.\r\n    gl.bufferData(\r\n      gl.ARRAY_BUFFER,\r\n      // Prettier mangles the formatting here but every 2 array values make one (x, y) pair\r\n      // and every 6 values make one triangle\r\n      new Float32Array([0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0]),\r\n      gl.STATIC_DRAW\r\n    );\r\n\r\n    // Set the active texture unit to 0.\r\n    gl.activeTexture(gl.TEXTURE0);\r\n\r\n    this._penSkin = new PenSkin(this, w, h);\r\n\r\n    // This framebuffer is where sprites are drawn for e.g. \"touching\" checks.\r\n    this._collisionBuffer = this._createFramebufferInfo(\r\n      w,\r\n      h,\r\n      gl.NEAREST,\r\n      true // stencil\r\n    );\r\n  }\r\n\r\n  // Create a framebuffer info object, which contains the following:\r\n  // * The framebuffer itself.\r\n  // * The texture backing the framebuffer.\r\n  // * The resolution (width and height) of the framebuffer.\r\n  _createFramebufferInfo(width, height, filtering, stencil = false) {\r\n    // Create an empty texture with this skin's dimensions.\r\n    const gl = this.gl;\r\n    const texture = gl.createTexture();\r\n    gl.bindTexture(gl.TEXTURE_2D, texture);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filtering);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filtering);\r\n    gl.texImage2D(\r\n      gl.TEXTURE_2D,\r\n      0,\r\n      gl.RGBA,\r\n      width,\r\n      height,\r\n      0,\r\n      gl.RGBA,\r\n      gl.UNSIGNED_BYTE,\r\n      null\r\n    );\r\n\r\n    // Create a framebuffer backed by said texture. This means we can draw onto the framebuffer,\r\n    // and the results appear in the texture.\r\n    const framebufferInfo = {\r\n      texture,\r\n      width,\r\n      height,\r\n      framebuffer: gl.createFramebuffer()\r\n    };\r\n    this._setFramebuffer(framebufferInfo);\r\n    gl.framebufferTexture2D(\r\n      gl.FRAMEBUFFER,\r\n      gl.COLOR_ATTACHMENT0,\r\n      gl.TEXTURE_2D,\r\n      texture,\r\n      0\r\n    );\r\n\r\n    // The depth buffer is unnecessary, but WebGL only guarantees\r\n    // that certain combinations of framebuffer attachments will work, and \"stencil but no depth\" is not among them.\r\n    if (stencil) {\r\n      const renderbuffer = gl.createRenderbuffer();\r\n      gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);\r\n      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height);\r\n      gl.framebufferRenderbuffer(\r\n        gl.FRAMEBUFFER,\r\n        gl.DEPTH_STENCIL_ATTACHMENT,\r\n        gl.RENDERBUFFER,\r\n        renderbuffer\r\n      );\r\n    }\r\n\r\n    return framebufferInfo;\r\n  }\r\n\r\n  _setShader(shader) {\r\n    if (shader !== this._currentShader) {\r\n      const gl = this.gl;\r\n      gl.useProgram(shader.program);\r\n\r\n      // These attributes and uniforms don't ever change, but must be set whenever a new shader program is used.\r\n\r\n      const attribLocation = shader.attribs.a_position;\r\n      gl.enableVertexAttribArray(attribLocation);\r\n      // Bind the 'a_position' vertex attribute to the current contents of `gl.ARRAY_BUFFER`, which in this case\r\n      // is a quadrilateral (as buffered earlier).\r\n      gl.vertexAttribPointer(\r\n        attribLocation,\r\n        2, // every 2 array elements make one vertex.\r\n        gl.FLOAT, // data type\r\n        false, // normalized\r\n        0, // stride (space between attributes)\r\n        0 // offset (index of the first attribute to start from)\r\n      );\r\n\r\n      this._currentShader = shader;\r\n      this._updateStageSize();\r\n\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  _setFramebuffer(framebufferInfo) {\r\n    if (framebufferInfo !== this._currentFramebuffer) {\r\n      this._currentFramebuffer = framebufferInfo;\r\n      if (framebufferInfo === null) {\r\n        // The \"null\" framebuffer means the drawing buffer which we're displaying to the screen.\r\n        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);\r\n        this._updateStageSize();\r\n      } else {\r\n        this.gl.bindFramebuffer(\r\n          this.gl.FRAMEBUFFER,\r\n          framebufferInfo.framebuffer\r\n        );\r\n        // Make sure to update the drawing viewport to the current framebuffer size.\r\n        this.gl.viewport(0, 0, framebufferInfo.width, framebufferInfo.height);\r\n      }\r\n    }\r\n  }\r\n\r\n  setRenderTarget(renderTarget) {\r\n    if (typeof renderTarget === \"string\") {\r\n      renderTarget = document.querySelector(renderTarget);\r\n    }\r\n    this.renderTarget = renderTarget;\r\n    this.renderTarget.classList.add(\"leopard__project\");\r\n    this.renderTarget.style.width = `${this.project.stage.width}px`;\r\n    this.renderTarget.style.height = `${this.project.stage.height}px`;\r\n\r\n    this.renderTarget.append(this.stage);\r\n  }\r\n\r\n  // Handles rendering of all layers (including stage, pen layer, sprites, and all clones) in proper order.\r\n  _renderLayers(layers, options = {}) {\r\n    options = Object.assign(\r\n      {},\r\n      {\r\n        drawMode: ShaderManager.DrawModes.DEFAULT,\r\n        renderSpeechBubbles: true\r\n      },\r\n      options\r\n    );\r\n\r\n    // If we're given a list of layers, filter by that.\r\n    // If we're given a filter function in the options, filter by that too.\r\n    // If we're given both, then only include layers which match both.\r\n    const shouldRestrictLayers = layers instanceof Set;\r\n    const shouldFilterLayers = typeof options.filter === \"function\";\r\n    const shouldIncludeLayer = layer =>\r\n      !(\r\n        (shouldRestrictLayers && !layers.has(layer)) ||\r\n        (shouldFilterLayers && !options.filter(layer))\r\n      );\r\n\r\n    // Stage\r\n    if (shouldIncludeLayer(this.project.stage)) {\r\n      this.renderSprite(this.project.stage, options);\r\n    }\r\n\r\n    // Pen layer\r\n    if (shouldIncludeLayer(this._penSkin)) {\r\n      const penMatrix = Matrix.create();\r\n      Matrix.scale(\r\n        penMatrix,\r\n        penMatrix,\r\n        this._penSkin.width,\r\n        -this._penSkin.height\r\n      );\r\n      Matrix.translate(penMatrix, penMatrix, -0.5, -0.5);\r\n\r\n      this._setSkinUniforms(\r\n        this._penSkin,\r\n        options.drawMode,\r\n        penMatrix,\r\n        1,\r\n        null\r\n      );\r\n      this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);\r\n    }\r\n\r\n    // Sprites + clones\r\n    for (const sprite of this.project.spritesAndClones) {\r\n      // Stage doesn't have \"visible\" defined, so check if it's strictly false\r\n      if (shouldIncludeLayer(sprite) && sprite.visible !== false) {\r\n        this.renderSprite(sprite, options);\r\n      }\r\n    }\r\n  }\r\n\r\n  _updateStageSize() {\r\n    if (this._currentShader) {\r\n      // The shader is passed things in \"Scratch-space\" (-240, 240) and (-180, 180).\r\n      // This tells it those dimensions so it can convert them to OpenGL \"clip-space\" (-1, 1).\r\n      this.gl.uniform2f(\r\n        this._currentShader.uniforms.u_stageSize,\r\n        this.project.stage.width,\r\n        this.project.stage.height\r\n      );\r\n    }\r\n\r\n    if (this._currentFramebuffer === null) {\r\n      this.gl.viewport(\r\n        0,\r\n        0,\r\n        this.gl.drawingBufferWidth,\r\n        this.gl.drawingBufferHeight\r\n      );\r\n    }\r\n  }\r\n\r\n  // Keep the canvas size in sync with the CSS size.\r\n  _resize() {\r\n    const stageSize = this.stage.getBoundingClientRect();\r\n    const ratio = window.devicePixelRatio;\r\n    const adjustedWidth = Math.round(stageSize.width * ratio);\r\n    const adjustedHeight = Math.round(stageSize.height * ratio);\r\n    if (\r\n      this.stage.width !== adjustedWidth ||\r\n      this.stage.height !== adjustedHeight\r\n    ) {\r\n      this.stage.width = adjustedWidth;\r\n      this.stage.height = adjustedHeight;\r\n      this._screenSpaceScale = Math.max(\r\n        adjustedWidth / this.project.stage.width,\r\n        adjustedHeight / this.project.stage.height\r\n      );\r\n\r\n      this._updateStageSize();\r\n    }\r\n  }\r\n\r\n  update() {\r\n    this._resize();\r\n\r\n    // Draw to the screen, not to a framebuffer.\r\n    this._setFramebuffer(null);\r\n\r\n    // Clear to opaque white.\r\n    const gl = this.gl;\r\n    gl.clearColor(1, 1, 1, 1);\r\n    gl.clear(gl.COLOR_BUFFER_BIT);\r\n\r\n    // TODO: find a way to not destroy the skins of hidden sprites\r\n    this._skinCache.beginTrace();\r\n    this._renderLayers();\r\n    this._skinCache.endTrace();\r\n  }\r\n\r\n  createStage(w, h) {\r\n    const stage = document.createElement(\"canvas\");\r\n    stage.width = w;\r\n    stage.height = h;\r\n\r\n    // Size canvas to parent container\r\n    stage.style.width = stage.style.height = \"100%\";\r\n\r\n    // If the container width is a non-integer size, don't blur the canvas.\r\n    // Chrome:\r\n    stage.style.imageRendering = \"pixelated\";\r\n    // Firefox:\r\n    stage.style.imageRendering = \"crisp-edges\";\r\n    // Safari + Opera:\r\n    stage.style.imageRendering = \"-webkit-optimize-contrast\";\r\n\r\n    return stage;\r\n  }\r\n\r\n  _setSkinUniforms(skin, drawMode, matrix, scale, effects, effectMask) {\r\n    const gl = this.gl;\r\n\r\n    const skinTexture = skin.getTexture(scale * this._screenSpaceScale);\r\n    if (!skinTexture) return;\r\n\r\n    let effectBitmask = 0;\r\n    if (effects) effectBitmask = effects._bitmask;\r\n    if (typeof effectMask === \"number\") effectBitmask &= effectMask;\r\n    const shader = this._shaderManager.getShader(drawMode, effectBitmask);\r\n    this._setShader(shader);\r\n    gl.uniformMatrix3fv(shader.uniforms.u_transform, false, matrix);\r\n\r\n    if (effectBitmask !== 0) {\r\n      for (const effect of Object.keys(effects._effectValues)) {\r\n        const effectVal = effects._effectValues[effect];\r\n        if (effectVal !== 0)\r\n          gl.uniform1f(shader.uniforms[`u_${effect}`], effectVal);\r\n      }\r\n\r\n      // Pixelate effect needs the skin size\r\n      if (effects._effectValues.pixelate !== 0)\r\n        gl.uniform2f(shader.uniforms.u_skinSize, skin.width, skin.height);\r\n    }\r\n\r\n    gl.bindTexture(gl.TEXTURE_2D, skinTexture);\r\n    // All textures are bound to texture unit 0, so that's where the texture sampler should point\r\n    gl.uniform1i(shader.uniforms.u_texture, 0);\r\n  }\r\n\r\n  // Calculate the transform matrix for a sprite.\r\n  // TODO: store the transform matrix in the sprite itself. That adds some complexity though,\r\n  // so it's better off in another PR.\r\n  _calculateSpriteMatrix(spr) {\r\n    // These transforms are actually in reverse order because lol matrices\r\n    const m = Matrix.create();\r\n    if (!(spr instanceof Stage)) {\r\n      Matrix.translate(m, m, spr.x, spr.y);\r\n      switch (spr.rotationStyle) {\r\n        case Sprite.RotationStyle.ALL_AROUND: {\r\n          Matrix.rotate(m, m, spr.scratchToRad(spr.direction));\r\n          break;\r\n        }\r\n        case Sprite.RotationStyle.LEFT_RIGHT: {\r\n          if (spr.direction < 0) Matrix.scale(m, m, -1, 1);\r\n          break;\r\n        }\r\n      }\r\n\r\n      const spriteScale = spr.size / 100;\r\n      Matrix.scale(m, m, spriteScale, spriteScale);\r\n    }\r\n\r\n    const scalingFactor = 1 / spr.costume.resolution;\r\n    // Rotation centers are in non-Scratch space (positive y-values = down),\r\n    // but these transforms are in Scratch space (negative y-values = down).\r\n    Matrix.translate(\r\n      m,\r\n      m,\r\n      -spr.costume.center.x * scalingFactor,\r\n      (spr.costume.center.y - spr.costume.height) * scalingFactor\r\n    );\r\n    Matrix.scale(\r\n      m,\r\n      m,\r\n      spr.costume.width * scalingFactor,\r\n      spr.costume.height * scalingFactor\r\n    );\r\n\r\n    return m;\r\n  }\r\n\r\n  // Calculate the transform matrix for a speech bubble attached to a sprite.\r\n  _calculateSpeechBubbleMatrix(spr, speechBubbleSkin) {\r\n    const sprBounds = this.getBoundingBox(spr);\r\n    let x;\r\n    if (\r\n      speechBubbleSkin.width + sprBounds.right >\r\n      this.project.stage.width / 2\r\n    ) {\r\n      x = sprBounds.left - speechBubbleSkin.width;\r\n      speechBubbleSkin.flipped = true;\r\n    } else {\r\n      x = sprBounds.right;\r\n      speechBubbleSkin.flipped = false;\r\n    }\r\n    x = Math.round(x - speechBubbleSkin.offsetX);\r\n    const y = Math.round(sprBounds.top - speechBubbleSkin.offsetY);\r\n\r\n    const m = Matrix.create();\r\n    Matrix.translate(m, m, x, y);\r\n    Matrix.scale(m, m, speechBubbleSkin.width, speechBubbleSkin.height);\r\n\r\n    return m;\r\n  }\r\n\r\n  renderSprite(sprite, options) {\r\n    const spriteScale = Object.prototype.hasOwnProperty.call(sprite, \"size\")\r\n      ? sprite.size / 100\r\n      : 1;\r\n\r\n    this._setSkinUniforms(\r\n      this._skinCache.getSkin(sprite.costume),\r\n      options.drawMode,\r\n      this._calculateSpriteMatrix(sprite),\r\n      spriteScale,\r\n      sprite.effects,\r\n      options.effectMask\r\n    );\r\n    if (Array.isArray(options.colorMask))\r\n      this.gl.uniform4fv(\r\n        this._currentShader.uniforms.u_colorMask,\r\n        options.colorMask\r\n      );\r\n    this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);\r\n\r\n    if (\r\n      options.renderSpeechBubbles &&\r\n      sprite._speechBubble &&\r\n      sprite._speechBubble.text !== \"\"\r\n    ) {\r\n      const speechBubbleSkin = this._skinCache.getSkin(sprite._speechBubble);\r\n\r\n      this._setSkinUniforms(\r\n        speechBubbleSkin,\r\n        options.drawMode,\r\n        this._calculateSpeechBubbleMatrix(sprite, speechBubbleSkin),\r\n        1,\r\n        null\r\n      );\r\n      this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);\r\n    }\r\n  }\r\n\r\n  getBoundingBox(sprite) {\r\n    return Rectangle.fromMatrix(this._calculateSpriteMatrix(sprite));\r\n  }\r\n\r\n  // Mask drawing in to only areas where this sprite is opaque.\r\n  _stencilSprite(spr, colorMask) {\r\n    const gl = this.gl;\r\n    gl.clearColor(0, 0, 0, 0);\r\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);\r\n\r\n    // Enable stenciling. This means that:\r\n    // 1. Only pixels which pass the \"stencil test\" will be drawn.\r\n    // 2. Anything rendered will also draw to the stencil buffer.\r\n    gl.enable(gl.STENCIL_TEST);\r\n    // Pass the stencil test regardless of what's in the stencil buffer.\r\n    // Note that pixels which the shader has discarded will still fail the stencil test.\r\n    // 1 is the reference value which we use in the next line.\r\n    gl.stencilFunc(gl.ALWAYS, 1, 1);\r\n    // If the stencil test passes (in this case, if the shader hasn't discarded the pixel),\r\n    // draw a 1 to that pixel in the stencil buffer, replacing whatever's already there.\r\n    gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);\r\n    // Don't draw to the color buffer. Only to the stencil buffer.\r\n    gl.colorMask(false, false, false, false);\r\n    // Draw the sprite in the \"silhouette\" mode, which discards transparent pixels.\r\n    // This, along with the above line, has the effect of not drawing anything to the color buffer, but\r\n    // creating a \"mask\" in the stencil buffer that masks out all pixels where this sprite is transparent.\r\n\r\n    const opts = {\r\n      drawMode: ShaderManager.DrawModes.SILHOUETTE,\r\n      renderSpeechBubbles: false,\r\n      // Ignore ghost effect\r\n      effectMask: ~effectBitmasks.ghost\r\n    };\r\n\r\n    // If we mask in the color (for e.g. \"color is touching color\"),\r\n    // we need to pass that in as a uniform as well.\r\n    if (colorMask) {\r\n      opts.colorMask = colorMask.toRGBANormalized();\r\n      opts.drawMode = ShaderManager.DrawModes.COLOR_MASK;\r\n    }\r\n    this._renderLayers(new Set([spr]), opts);\r\n\r\n    // Pass the stencil test if the stencil buffer value equals 1 (e.g. the pixel got masked in above).\r\n    gl.stencilFunc(gl.EQUAL, 1, 1);\r\n    // Keep the current stencil buffer values no matter what.\r\n    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);\r\n    // We can draw to the color buffer again. Note that only pixels which pass the stencil test are drawn.\r\n    gl.colorMask(true, true, true, true);\r\n  }\r\n\r\n  checkSpriteCollision(spr, targets, fast, sprColor) {\r\n    if (!spr.visible) return false;\r\n    if (!(targets instanceof Set)) {\r\n      if (targets instanceof Array) {\r\n        targets = new Set(targets);\r\n      } else {\r\n        targets = new Set([targets]);\r\n      }\r\n    }\r\n\r\n    const sprBox = this.getBoundingBox(spr).snapToInt();\r\n\r\n    // This is an \"impossible rectangle\"-- its left bound is infinitely far to the right,\r\n    // its right bound is infinitely to the left, and so on. Its size is effectively -Infinity.\r\n    // Its only purpose is to be the \"identity rectangle\" that starts the rectangle union process.\r\n    const targetBox = Rectangle.fromBounds(\r\n      Infinity,\r\n      -Infinity,\r\n      Infinity,\r\n      -Infinity\r\n    );\r\n    for (const target of targets) {\r\n      Rectangle.union(\r\n        targetBox,\r\n        this.getBoundingBox(target).snapToInt(),\r\n        targetBox\r\n      );\r\n    }\r\n\r\n    if (!sprBox.intersects(targetBox)) return false;\r\n    if (fast) return true;\r\n\r\n    const cx = this._collisionBuffer.width / 2;\r\n    const cy = this._collisionBuffer.height / 2;\r\n    const collisionBox = Rectangle.intersection(sprBox, targetBox).clamp(\r\n      -cx,\r\n      cx,\r\n      -cy,\r\n      cy\r\n    );\r\n\r\n    if (collisionBox.width === 0 || collisionBox.height === 0) return false;\r\n\r\n    this._setFramebuffer(this._collisionBuffer);\r\n    // Enable stencil testing then stencil in this sprite, which masks all further drawing to this sprite's area.\r\n    this._stencilSprite(spr, sprColor);\r\n\r\n    // Render the sprites to check that we're touching, which will now be masked in to the area of the first sprite.\r\n    this._renderLayers(targets, {\r\n      drawMode: ShaderManager.DrawModes.SILHOUETTE,\r\n      // Ignore ghost effect\r\n      effectMask: ~effectBitmasks.ghost\r\n    });\r\n\r\n    const gl = this.gl;\r\n    // Make sure to disable the stencil test so as not to affect other rendering!\r\n    gl.disable(gl.STENCIL_TEST);\r\n\r\n    const pixelData = new Uint8Array(\r\n      collisionBox.width * collisionBox.height * 4\r\n    );\r\n    gl.readPixels(\r\n      collisionBox.left + cx,\r\n      collisionBox.bottom + cy,\r\n      collisionBox.width,\r\n      collisionBox.height,\r\n      gl.RGBA,\r\n      gl.UNSIGNED_BYTE,\r\n      pixelData\r\n    );\r\n\r\n    // Any opaque pixel = an overlap between the two sprites.\r\n    for (let i = 0; i < pixelData.length; i += 4) {\r\n      if (pixelData[i + 3] !== 0) return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  checkColorCollision(spr, targetsColor, sprColor) {\r\n    const sprBox = this.getBoundingBox(spr).snapToInt();\r\n\r\n    const cx = this._collisionBuffer.width / 2;\r\n    const cy = this._collisionBuffer.height / 2;\r\n    sprBox.clamp(-cx, cx, -cy, cy);\r\n\r\n    if (sprBox.width === 0 || sprBox.height === 0) return false;\r\n\r\n    this._setFramebuffer(this._collisionBuffer);\r\n    const gl = this.gl;\r\n    gl.clearColor(0, 0, 0, 0);\r\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);\r\n\r\n    this._setFramebuffer(this._collisionBuffer);\r\n    // Enable stencil testing then stencil in this sprite, which masks all further drawing to this sprite's area.\r\n    this._stencilSprite(spr, sprColor);\r\n\r\n    // Render the sprites to check that we're touching, which will now be masked in to the area of the first sprite.\r\n    this._renderLayers(null, {\r\n      filter: layer => layer !== spr\r\n    });\r\n\r\n    // Make sure to disable the stencil test so as not to affect other rendering!\r\n    gl.disable(gl.STENCIL_TEST);\r\n\r\n    const pixelData = new Uint8Array(sprBox.width * sprBox.height * 4);\r\n    gl.readPixels(\r\n      sprBox.left + cx,\r\n      sprBox.bottom + cy,\r\n      sprBox.width,\r\n      sprBox.height,\r\n      gl.RGBA,\r\n      gl.UNSIGNED_BYTE,\r\n      pixelData\r\n    );\r\n\r\n    const color = targetsColor.toRGBA();\r\n    for (let i = 0; i < pixelData.length; i += 4) {\r\n      if (\r\n        // Ensure we're not testing transparent pixels\r\n        pixelData[i + 3] !== 0 &&\r\n        // Scratch tests the top 5 bits of the red and green channels,\r\n        // and the top 4 bits of the blue channel.\r\n        ((pixelData[i] ^ color[0]) & 0b11111000) === 0 &&\r\n        ((pixelData[i + 1] ^ color[1]) & 0b11111000) === 0 &&\r\n        ((pixelData[i + 2] ^ color[2]) & 0b11110000) === 0\r\n      )\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  checkPointCollision(spr, point, fast) {\r\n    if (!spr.visible) return false;\r\n\r\n    const box = this.getBoundingBox(spr);\r\n    if (!box.containsPoint(point.x, point.y)) return false;\r\n    if (fast) return true;\r\n\r\n    // TODO: would it be faster to enable a scissor rectangle?\r\n    this._setFramebuffer(this._collisionBuffer);\r\n    const gl = this.gl;\r\n    gl.clearColor(0, 0, 0, 0);\r\n    gl.clear(gl.COLOR_BUFFER_BIT);\r\n\r\n    this._renderLayers(new Set([spr]), { effectMask: ~effectBitmasks.ghost });\r\n\r\n    const hoveredPixel = new Uint8Array(4);\r\n    const cx = this._collisionBuffer.width / 2;\r\n    const cy = this._collisionBuffer.height / 2;\r\n    gl.readPixels(\r\n      point.x + cx,\r\n      point.y + cy,\r\n      1,\r\n      1,\r\n      gl.RGBA,\r\n      gl.UNSIGNED_BYTE,\r\n      hoveredPixel\r\n    );\r\n    return hoveredPixel[3] !== 0;\r\n  }\r\n\r\n  penLine(pt1, pt2, color, size) {\r\n    this._penSkin.penLine(pt1, pt2, color, size);\r\n  }\r\n\r\n  clearPen() {\r\n    this._penSkin.clear();\r\n  }\r\n\r\n  stamp(spr) {\r\n    this._setFramebuffer(this._penSkin._framebufferInfo);\r\n    this._renderLayers(new Set([spr]), { renderSpeechBubbles: false });\r\n  }\r\n\r\n  displayAskBox(question) {\r\n    const askBox = document.createElement(\"form\");\r\n    askBox.classList.add(\"leopard__askBox\");\r\n\r\n    const askText = document.createElement(\"span\");\r\n    askText.classList.add(\"leopard__askText\");\r\n    askText.innerText = question;\r\n    askBox.append(askText);\r\n\r\n    const askInput = document.createElement(\"input\");\r\n    askInput.type = \"text\";\r\n    askInput.classList.add(\"leopard__askInput\");\r\n    askBox.append(askInput);\r\n\r\n    const askButton = document.createElement(\"button\");\r\n    askButton.classList.add(\"leopard__askButton\");\r\n    askButton.innerText = \"Answer\";\r\n    askBox.append(askButton);\r\n\r\n    this.renderTarget.append(askBox);\r\n    askInput.focus();\r\n\r\n    return new Promise(resolve => {\r\n      askBox.addEventListener(\"submit\", e => {\r\n        e.preventDefault();\r\n        askBox.remove();\r\n        resolve(askInput.value);\r\n      });\r\n    });\r\n  }\r\n}\r\n","export default class Input {\r\n  constructor(stage, canvas, onKeyDown) {\r\n    this._stage = stage;\r\n    this._canvas = canvas;\r\n\r\n    // Allow setting focus to canvas\r\n    if (this._canvas.tabIndex < 0) {\r\n      this._canvas.tabIndex = 0;\r\n    }\r\n\r\n    this.mouse = { x: 0, y: 0, down: false };\r\n    this._canvas.addEventListener(\"mousemove\", this._mouseMove.bind(this));\r\n    this._canvas.addEventListener(\"mousedown\", this._mouseDown.bind(this));\r\n    this._canvas.addEventListener(\"mouseup\", this._mouseUp.bind(this));\r\n\r\n    this._canvas.addEventListener(\"keyup\", this._keyup.bind(this));\r\n    this._canvas.addEventListener(\"keydown\", this._keydown.bind(this));\r\n\r\n    this.keys = [];\r\n    this._onKeyDown = onKeyDown;\r\n  }\r\n\r\n  _mouseMove(e) {\r\n    const rect = this._canvas.getBoundingClientRect();\r\n    const scaleX = this._stage.width / rect.width;\r\n    const scaleY = this._stage.height / rect.height;\r\n    const realCoords = {\r\n      x: (e.clientX - rect.left) * scaleX,\r\n      y: (e.clientY - rect.top) * scaleY\r\n    };\r\n\r\n    this.mouse = {\r\n      ...this.mouse,\r\n      x: realCoords.x - this._stage.width / 2,\r\n      y: -realCoords.y + this._stage.height / 2\r\n    };\r\n  }\r\n\r\n  _mouseDown() {\r\n    this.mouse = {\r\n      ...this.mouse,\r\n      down: true\r\n    };\r\n  }\r\n\r\n  _mouseUp() {\r\n    this.mouse = {\r\n      ...this.mouse,\r\n      down: false\r\n    };\r\n  }\r\n\r\n  _keyup(e) {\r\n    const key = this._getKeyName(e);\r\n    this.keys = this.keys.filter(k => k !== key);\r\n  }\r\n\r\n  _keydown(e) {\r\n    e.preventDefault();\r\n\r\n    const key = this._getKeyName(e);\r\n    if (this.keys.indexOf(key) === -1) {\r\n      this.keys.push(key);\r\n    }\r\n\r\n    this._onKeyDown(key);\r\n  }\r\n\r\n  _getKeyName(e) {\r\n    if (e.key === \"ArrowUp\") return \"up arrow\";\r\n    if (e.key === \"ArrowDown\") return \"down arrow\";\r\n    if (e.key === \"ArrowLeft\") return \"left arrow\";\r\n    if (e.key === \"ArrowRight\") return \"right arrow\";\r\n    if (e.key === \" \") return \"space\";\r\n    if (e.code.substring(0, 5) === \"Digit\") return e.code[5];\r\n\r\n    return e.key.toLowerCase();\r\n  }\r\n\r\n  keyPressed(name) {\r\n    if (name === \"any\") return this.keys.length > 0;\r\n    return this.keys.indexOf(name) > -1;\r\n  }\r\n\r\n  focus() {\r\n    this._canvas.focus();\r\n  }\r\n}\r\n","import Trigger from \"./Trigger.js\";\r\nimport Renderer from \"./Renderer.js\";\r\nimport Input from \"./Input.js\";\r\nimport { Stage } from \"./Sprite.js\";\r\n\r\nexport default class Project {\r\n  constructor(stage, sprites = {}, { frameRate = 30 } = {}) {\r\n    this.stage = stage;\r\n    this.sprites = sprites;\r\n\r\n    Object.freeze(sprites); // Prevent adding/removing sprites while project is running\r\n\r\n    for (const sprite of this.spritesAndClones) {\r\n      sprite._project = this;\r\n    }\r\n    this.stage._project = this;\r\n\r\n    this.renderer = new Renderer(this);\r\n    this.input = new Input(this.stage, this.renderer.stage, key => {\r\n      this.fireTrigger(Trigger.KEY_PRESSED, { key });\r\n    });\r\n\r\n    this.runningTriggers = [];\r\n\r\n    this.restartTimer();\r\n\r\n    this.answer = null;\r\n\r\n    // Run project code at specified framerate\r\n    setInterval(() => {\r\n      this.step();\r\n    }, 1000 / frameRate);\r\n\r\n    // Render project as fast as possible\r\n    this._renderLoop();\r\n  }\r\n\r\n  attach(renderTarget) {\r\n    this.renderer.setRenderTarget(renderTarget);\r\n    this.renderer.stage.addEventListener(\"click\", () => {\r\n      const wasClicked = sprite => {\r\n        if (sprite instanceof Stage) {\r\n          return true;\r\n        }\r\n\r\n        return this.renderer.checkPointCollision(\r\n          sprite,\r\n          {\r\n            x: this.input.mouse.x,\r\n            y: this.input.mouse.y\r\n          },\r\n          false\r\n        );\r\n      };\r\n\r\n      let matchingTriggers = [];\r\n      for (let i = 0; i < this.spritesAndStage.length; i++) {\r\n        const sprite = this.spritesAndStage[i];\r\n        const spriteClickedTriggers = sprite.triggers.filter(tr =>\r\n          tr.matches(Trigger.CLICKED, {})\r\n        );\r\n        if (spriteClickedTriggers.length > 0) {\r\n          if (wasClicked(sprite)) {\r\n            matchingTriggers = [\r\n              ...matchingTriggers,\r\n              ...spriteClickedTriggers.map(trigger => ({\r\n                trigger,\r\n                target: sprite\r\n              }))\r\n            ];\r\n          }\r\n        }\r\n      }\r\n\r\n      this._startTriggers(matchingTriggers);\r\n    });\r\n  }\r\n\r\n  greenFlag() {\r\n    this.fireTrigger(Trigger.GREEN_FLAG);\r\n    this.input.focus();\r\n  }\r\n\r\n  step() {\r\n    // Step all triggers\r\n    const alreadyRunningTriggers = this.runningTriggers;\r\n    for (let i = 0; i < alreadyRunningTriggers.length; i++) {\r\n      alreadyRunningTriggers[i].trigger.step();\r\n    }\r\n\r\n    // Remove finished triggers\r\n    this.runningTriggers = this.runningTriggers.filter(\r\n      ({ trigger }) => !trigger.done\r\n    );\r\n  }\r\n\r\n  render() {\r\n    // Render to canvas\r\n    this.renderer.update(this.stage, this.spritesAndClones);\r\n\r\n    // Update watchers\r\n    for (const sprite of [...Object.values(this.sprites), this.stage]) {\r\n      for (const watcher of Object.values(sprite.watchers)) {\r\n        watcher.updateDOM(this.renderer.renderTarget);\r\n      }\r\n    }\r\n  }\r\n\r\n  _renderLoop() {\r\n    requestAnimationFrame(this._renderLoop.bind(this));\r\n    this.render();\r\n  }\r\n\r\n  fireTrigger(trigger, options) {\r\n    // Special trigger behaviors\r\n    if (trigger === Trigger.GREEN_FLAG) {\r\n      this.restartTimer();\r\n      this.stopAllSounds();\r\n      this.runningTriggers = [];\r\n\r\n      for (const spriteName in this.sprites) {\r\n        const sprite = this.sprites[spriteName];\r\n        sprite.clones = [];\r\n      }\r\n\r\n      for (const sprite of this.spritesAndStage) {\r\n        sprite.effects.clear();\r\n        sprite.audioEffects.clear();\r\n      }\r\n    }\r\n\r\n    // Find triggers which match conditions\r\n    let matchingTriggers = [];\r\n    for (let i = 0; i < this.spritesAndStage.length; i++) {\r\n      const sprite = this.spritesAndStage[i];\r\n      const spriteTriggers = sprite.triggers.filter(tr =>\r\n        tr.matches(trigger, options)\r\n      );\r\n\r\n      matchingTriggers = [\r\n        ...matchingTriggers,\r\n        ...spriteTriggers.map(trigger => ({ trigger, target: sprite }))\r\n      ];\r\n    }\r\n\r\n    return this._startTriggers(matchingTriggers);\r\n  }\r\n\r\n  _startTriggers(triggers) {\r\n    // Only add these triggers to this.runningTriggers if they're not already there.\r\n    // TODO: if the triggers are already running, they'll be restarted but their execution order is unchanged.\r\n    // Does that match Scratch's behavior?\r\n    for (const trigger of triggers) {\r\n      if (\r\n        !this.runningTriggers.find(\r\n          runningTrigger =>\r\n            trigger.trigger === runningTrigger.trigger &&\r\n            trigger.target === runningTrigger.target\r\n        )\r\n      ) {\r\n        this.runningTriggers.push(trigger);\r\n      }\r\n    }\r\n    return Promise.all(\r\n      triggers.map(({ trigger, target }) => {\r\n        return trigger.start(target);\r\n      })\r\n    );\r\n  }\r\n\r\n  get spritesAndClones() {\r\n    return Object.values(this.sprites)\r\n      .flatMap(sprite => sprite.andClones())\r\n      .sort((a, b) => a._layerOrder - b._layerOrder);\r\n  }\r\n\r\n  get spritesAndStage() {\r\n    return [...this.spritesAndClones, this.stage];\r\n  }\r\n\r\n  changeSpriteLayer(sprite, layerDelta, relativeToSprite = sprite) {\r\n    let spritesArray = this.spritesAndClones;\r\n\r\n    const originalIndex = spritesArray.indexOf(sprite);\r\n    const relativeToIndex = spritesArray.indexOf(relativeToSprite);\r\n\r\n    let newIndex = relativeToIndex + layerDelta;\r\n    if (newIndex < 0) newIndex = 0;\r\n    if (newIndex > spritesArray.length - 1) newIndex = spritesArray.length - 1;\r\n\r\n    // Remove sprite from originalIndex and insert at newIndex\r\n    spritesArray.splice(originalIndex, 1);\r\n    spritesArray.splice(newIndex, 0, sprite);\r\n\r\n    // spritesArray is sorted correctly, but to influence\r\n    // the actual order of the sprites we need to update\r\n    // each one's _layerOrder property.\r\n    spritesArray.forEach((sprite, index) => {\r\n      sprite._layerOrder = index + 1;\r\n    });\r\n  }\r\n\r\n  stopAllSounds() {\r\n    for (const target of this.spritesAndStage) {\r\n      target.stopAllOfMySounds();\r\n    }\r\n  }\r\n\r\n  restartTimer() {\r\n    this.timerStart = new Date();\r\n  }\r\n\r\n  async askAndWait(question) {\r\n    this.answer = await this.renderer.displayAskBox(question);\r\n  }\r\n}\r\n","import Color from \"./Color\";\r\n\r\nexport default class Watcher {\r\n  constructor({\r\n    value = () => \"\",\r\n    setValue = () => {},\r\n    label,\r\n    style = \"normal\",\r\n    visible = true,\r\n    color = Color.rgb(255, 140, 26),\r\n    step = 1,\r\n    x = -240,\r\n    y = 180,\r\n    width,\r\n    height\r\n  }) {\r\n    this.initializeDOM();\r\n\r\n    this.value = value;\r\n    this.setValue = setValue;\r\n    this._previousValue = Symbol(\"NO_PREVIOUS_VALUE\");\r\n\r\n    this.label = label;\r\n    this.style = style;\r\n    this.visible = visible;\r\n    this.color = color;\r\n    this.step = step;\r\n\r\n    this.x = x;\r\n    this.y = y;\r\n    this.width = width;\r\n    this.height = height;\r\n  }\r\n\r\n  initializeDOM() {\r\n    const node = document.createElement(\"div\");\r\n    node.classList.add(\"leopard__watcher\");\r\n\r\n    const label = document.createElement(\"div\");\r\n    label.classList.add(\"leopard__watcherLabel\");\r\n    node.append(label);\r\n\r\n    const value = document.createElement(\"div\");\r\n    value.classList.add(\"leopard__watcherValue\");\r\n    node.append(value);\r\n\r\n    const slider = document.createElement(\"input\");\r\n    slider.type = \"range\";\r\n    slider.classList.add(\"leopard__watcherSlider\");\r\n\r\n    slider.addEventListener(\"input\", event => {\r\n      this.setValue(Number(event.target.value));\r\n    });\r\n\r\n    node.append(slider);\r\n\r\n    this._dom = { node, label, value, slider };\r\n  }\r\n\r\n  updateDOM(renderTarget) {\r\n    if (renderTarget && !renderTarget.contains(this._dom.node)) {\r\n      renderTarget.append(this._dom.node);\r\n    }\r\n\r\n    if (!this.visible) return;\r\n\r\n    const value = this.value();\r\n\r\n    const isList = Array.isArray(value);\r\n    this._dom.node.classList.toggle(\"leopard__watcher--list\", isList);\r\n    if (isList) {\r\n      // Render like a list\r\n      if (\r\n        !Array.isArray(this._previousValue) ||\r\n        JSON.stringify(value.map(String)) !==\r\n          JSON.stringify(this._previousValue.map(String))\r\n      ) {\r\n        this._dom.value.innerHTML = \"\";\r\n        for (const [index, item] of value.entries()) {\r\n          const itemElem = document.createElement(\"div\");\r\n          itemElem.classList.add(\"leopard__watcherListItem\");\r\n\r\n          const indexElem = document.createElement(\"div\");\r\n          indexElem.classList.add(\"leopard__watcherListItemIndex\");\r\n          indexElem.innerText = index;\r\n\r\n          const contentElem = document.createElement(\"div\");\r\n          contentElem.classList.add(\"leopard__watcherListItemContent\");\r\n          contentElem.innerText = item.toString();\r\n\r\n          itemElem.append(indexElem);\r\n          itemElem.append(contentElem);\r\n          this._dom.value.append(itemElem);\r\n        }\r\n      }\r\n    } else {\r\n      // Render like a normal variable\r\n      if (value !== this._previousValue) {\r\n        this._dom.value.innerText = value.toString();\r\n      }\r\n    }\r\n\r\n    if (isList) {\r\n      this._previousValue = [...value];\r\n    } else {\r\n      this._previousValue = value;\r\n    }\r\n\r\n    // Set slider value\r\n    if (this._style === \"slider\") {\r\n      this._dom.slider.value = value;\r\n    }\r\n\r\n    // Update color\r\n    // (Needs to happen here rather than a setter because\r\n    // mutation of color object is possible.)\r\n    const textColor =\r\n      this.color.r * 0.299 + this.color.g * 0.587 + this.color.b * 0.114 > 162\r\n        ? \"#000\"\r\n        : \"#fff\";\r\n    this._dom.value.style.setProperty(\"--watcher-color\", this.color.toString());\r\n    this._dom.value.style.setProperty(\"--watcher-text-color\", textColor);\r\n  }\r\n\r\n  get visible() {\r\n    return this._visible;\r\n  }\r\n  set visible(visible) {\r\n    this._visible = visible;\r\n    this._dom.node.style.visibility = visible ? \"visible\" : \"hidden\";\r\n  }\r\n\r\n  get x() {\r\n    return this._x;\r\n  }\r\n  set x(x) {\r\n    this._x = x;\r\n    this._dom.node.style.left = `${x - 240}px`;\r\n  }\r\n\r\n  get y() {\r\n    return this._y;\r\n  }\r\n  set y(y) {\r\n    this._y = y;\r\n    this._dom.node.style.top = `${180 - y}px`;\r\n  }\r\n\r\n  get width() {\r\n    return this._width;\r\n  }\r\n  set width(width) {\r\n    this._width = width;\r\n    if (width) {\r\n      this._dom.node.style.width = `${width}px`;\r\n    } else {\r\n      this._dom.node.style.width = undefined;\r\n    }\r\n  }\r\n\r\n  get height() {\r\n    return this._height;\r\n  }\r\n  set height(height) {\r\n    this._height = height;\r\n    if (height) {\r\n      this._dom.node.style.height = `${height}px`;\r\n    } else {\r\n      this._dom.node.style.height = undefined;\r\n    }\r\n  }\r\n\r\n  get style() {\r\n    return this._style;\r\n  }\r\n  set style(style) {\r\n    this._style = style;\r\n    this._dom.node.classList.toggle(\r\n      \"leopard__watcher--normal\",\r\n      style === \"normal\"\r\n    );\r\n    this._dom.node.classList.toggle(\r\n      \"leopard__watcher--large\",\r\n      style === \"large\"\r\n    );\r\n    this._dom.node.classList.toggle(\r\n      \"leopard__watcher--slider\",\r\n      style === \"slider\"\r\n    );\r\n  }\r\n\r\n  get min() {\r\n    return this._min;\r\n  }\r\n  set min(min) {\r\n    this._min = min;\r\n    this._dom.slider.min = min;\r\n  }\r\n\r\n  get max() {\r\n    return this._max;\r\n  }\r\n  set max(max) {\r\n    this._max = max;\r\n    this._dom.slider.max = max;\r\n  }\r\n\r\n  get step() {\r\n    return this._step;\r\n  }\r\n  set step(step) {\r\n    this._step = step;\r\n    this._dom.slider.step = step;\r\n  }\r\n\r\n  get label() {\r\n    return this._label;\r\n  }\r\n  set label(label) {\r\n    this._label = label;\r\n    this._dom.label.innerText = label;\r\n  }\r\n}\r\n"],"names":["GREEN_FLAG","Symbol","KEY_PRESSED","BROADCAST","CLICKED","CLONE_START","Trigger","[object Object]","trigger","options","script","this","_script","done","stop","option","target","boundScript","bind","_runningScript","Promise","resolve","next","Matrix","matrix","Float32Array","dst","src","x","y","a00","a01","a02","a10","a11","a12","a20","a21","a22","rad","s","Math","sin","c","cos","Skin","renderer","gl","used","scale","image","filtering","glTexture","createTexture","bindTexture","TEXTURE_2D","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","TEXTURE_MIN_FILTER","TEXTURE_MAG_FILTER","texImage2D","RGBA","UNSIGNED_BYTE","complete","width","naturalWidth","height","naturalHeight","addEventListener","SpriteShader","vertex","fragment","PenLineShader","effectNames","effectBitmasks","i","length","Shader","program","uniforms","attribs","numActiveUniforms","getProgramParameter","ACTIVE_UNIFORMS","name","getActiveUniform","getUniformLocation","numActiveAttributes","ACTIVE_ATTRIBUTES","getActiveAttrib","getAttribLocation","ShaderManager","_shaderCache","drawMode","Object","keys","DrawModes","Map","source","type","shader","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","effectBitmask","shaderMap","has","get","shaderCode","DEFAULT","SILHOUETTE","COLOR_MASK","PEN_LINE","define","effectName","vertShader","_createShader","VERTEX_SHADER","fragShader","FRAGMENT_SHADER","createProgram","attachShader","linkProgram","LINK_STATUS","info","getProgramInfoLog","Error","set","PenSkin","super","framebufferInfo","_createFramebufferInfo","NEAREST","_framebufferInfo","_lastPenState","size","color","clear","deleteTexture","texture","deleteFramebuffer","framebuffer","pt1","pt2","_setFramebuffer","_shaderManager","getShader","shaderChanged","_setShader","uniform2f","u_penSkinSize","penColor","toRGBANormalized","oldColor","uniform4f","u_penColor","uniform1f","u_penSize","lineDiffX","lineDiffY","u_penPoints","lineLength","sqrt","u_lineLength","drawArrays","TRIANGLES","clearColor","COLOR_BUFFER_BIT","Rectangle","left","Infinity","right","bottom","top","result","xa","xb","absx","abs","sumx","ya","yb","absy","sumy","floor","ceil","rect","min","max","rect1","rect2","BitmapSkin","_image","_texture","_setSizeFromImage","_makeTexture","bubbleStyle","SpeechBubbleSkin","bubble","_canvas","document","createElement","LINEAR","_bubble","_flipped","_rendered","_renderedScale","offsetX","offsetY","_renderBubble","ctx","getContext","font","textBaseline","flipped","canvas","_restyleCanvas","text","style","textWidth","measureText","maxWidth","padding","setTransform","fillStyle","strokeStyle","lineWidth","save","translate","w","h","r","beginPath","moveTo","arcTo","lineTo","ellipse","PI","closePath","stroke","fill","renderBubbleBackground","restore","fillText","VectorSkin","_maxTextureSize","getParameter","MAX_TEXTURE_SIZE","_mipmaps","mipLevel","round","drawImage","log2","_createMipmap","mip","values","Costume","url","center","img","Image","crossOrigin","isBitmap","match","resolution","SkinCache","_renderer","_skins","forEach","skin","key","destroy","delete","obj","clamp","n","rgbToHSV","g","b","delta","v","hsvToRGB","Color","a","Number","rgb","_setRGB","_a","_h","_s","_v","forceIncludeAlpha","toHexDigits","str","toString","hex","map","join","toRGBString","ADPCM_STEPS","ADPCM_INDEX","decodeADPCMAudio","ab","audioContext","dv","DataView","getUint32","reject","blocks","l","byteLength","String","fromCharCode","getUint8","format","getUint16","sampleRate","blockSize","frameCount","fact","buffer","createBuffer","channel","getChannelData","sample","step","code","index","lastByte","offset","data","j","getInt16","isADPCMData","arrayBuffer","dataView","isWavData","Sound","audioBuffer","playbackRate","downloadMyAudioBuffer","duration","started","isLatestCallToStart","_markDone","playMyAudioBuffer","oldDoneDownloading","_doneDownloading","fromMoreRecentCall","playing","start","disconnect","fetch","then","body","catch","error","console","warn","decodeAudioData","createBufferSource","value","connect","currentTime","_setupAudioContext","_audioContext","AudioContext","window","webkitAudioContext","EffectChain","config","getNonPatchSoundList","inputNode","createGain","effectNodes","resetToInitial","initials","getInitialEffectValues","effectValues","initialValue","entries","getEffectDescriptor","reset","setEffectValue","descriptor","isPatch","getNextEffectDescriptor","previous","getPreviousEffectDescriptor","output","input","nodes","initial","makeNodes","node","Set","sound","last","getLastEffectDescriptor","isNaN","clampEffectValue","updateAudioEffect","minimum","maximum","newConfig","newEffectChain","assign","resetOnClone","isConnectedTo","effectDescriptors","find","slice","_","decayDuration","decayWait","aCtx","leftGain","rightGain","channelMerger","createChannelMerger","p","leftVal","rightVal","gain","setTargetAtTime","interval","ratio","pow","setPlaybackRate","resetOnStart","linearRampToValueAtTime","AudioEffectMap","effectChain","defineProperty","getEffectValue","_EffectMap","_bitmask","_effectValues","val","m","SpriteBase","initialConditions","vars","_project","costumeNumber","layerOrder","_costumeNumber","_layerOrder","triggers","watchers","costumes","sounds","getSoundsPlayedByMe","destination","effects","audioEffects","_vars","filter","isTargetOf","stage","sprites","number","costume","findIndex","lower","upper","excluded","possibleOptions","randInt","random","trim","changeSpriteLayer","deg","scratchDir","degToScratch","radToDeg","degToRad","scratchToDeg","procedure","bound","args","inst","secs","endTime","Date","setMilliseconds","getMilliseconds","mouse","keyPressed","timer","timerStart","restartTimer","soundName","getSound","applyToSound","playUntilDone","stopAllSounds","fireTrigger","running","broadcast","clearPen","question","_speechBubble","say","askAndWait","answer","Sprite","direction","rotationStyle","visible","penDown","penSize","_x","_y","_direction","RotationStyle","ALL_AROUND","parent","clones","_penDown","_penColor","timeout","clone","create","getPrototypeOf","_clone","original","push","tr","matches","_startTriggers","runningTriggers","flatMap","andClones","dir","normalizeDeg","penLine","goto","dist","moveDir","scratchToRad","seconds","interpolate","t","startTime","startX","startY","stamp","fast","checkPointCollision","checkColorCollision","checkSpriteCollision","clearTimeout","setTimeout","freeze","LEFT_RIGHT","DONT_ROTATE","Stage","defineProperties","enumerable","__counter","Renderer","project","renderTarget","createStage","antialias","setRenderTarget","_skinCache","_currentShader","_currentFramebuffer","_screenSpaceScale","enable","BLEND","blendFunc","ONE","ONE_MINUS_SRC_ALPHA","pixelStorei","UNPACK_PREMULTIPLY_ALPHA_WEBGL","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","activeTexture","TEXTURE0","_penSkin","_collisionBuffer","stencil","createFramebuffer","framebufferTexture2D","FRAMEBUFFER","COLOR_ATTACHMENT0","renderbuffer","createRenderbuffer","bindRenderbuffer","RENDERBUFFER","renderbufferStorage","DEPTH_STENCIL","framebufferRenderbuffer","DEPTH_STENCIL_ATTACHMENT","useProgram","attribLocation","a_position","enableVertexAttribArray","vertexAttribPointer","FLOAT","_updateStageSize","bindFramebuffer","viewport","querySelector","classList","add","append","layers","renderSpeechBubbles","shouldRestrictLayers","shouldFilterLayers","shouldIncludeLayer","layer","renderSprite","penMatrix","_setSkinUniforms","sprite","spritesAndClones","u_stageSize","drawingBufferWidth","drawingBufferHeight","stageSize","getBoundingClientRect","devicePixelRatio","adjustedWidth","adjustedHeight","_resize","beginTrace","_renderLayers","endTrace","imageRendering","effectMask","skinTexture","getTexture","uniformMatrix3fv","u_transform","effect","effectVal","pixelate","u_skinSize","uniform1i","u_texture","spr","rotate","spriteScale","scalingFactor","speechBubbleSkin","sprBounds","getBoundingBox","prototype","hasOwnProperty","call","getSkin","_calculateSpriteMatrix","Array","isArray","colorMask","uniform4fv","u_colorMask","_calculateSpeechBubbleMatrix","fromMatrix","STENCIL_BUFFER_BIT","STENCIL_TEST","stencilFunc","ALWAYS","stencilOp","KEEP","REPLACE","opts","ghost","EQUAL","targets","sprColor","sprBox","snapToInt","targetBox","fromBounds","union","intersects","cx","cy","collisionBox","intersection","_stencilSprite","disable","pixelData","Uint8Array","readPixels","targetsColor","toRGBA","point","containsPoint","hoveredPixel","askBox","askText","innerText","askInput","askButton","focus","e","preventDefault","remove","Input","onKeyDown","_stage","tabIndex","down","_mouseMove","_mouseDown","_mouseUp","_keyup","_keydown","_onKeyDown","scaleX","scaleY","realCoords","clientX","clientY","_getKeyName","k","indexOf","substring","toLowerCase","Project","frameRate","setInterval","_renderLoop","wasClicked","matchingTriggers","spritesAndStage","spriteClickedTriggers","alreadyRunningTriggers","update","watcher","updateDOM","requestAnimationFrame","render","spriteName","spriteTriggers","runningTrigger","all","sort","layerDelta","relativeToSprite","spritesArray","originalIndex","newIndex","splice","stopAllOfMySounds","displayAskBox","Watcher","setValue","label","initializeDOM","_previousValue","slider","event","_dom","contains","isList","toggle","JSON","stringify","innerHTML","item","itemElem","indexElem","contentElem","_style","textColor","setProperty","_visible","visibility","_width","undefined","_height","_min","_max","_step","_label"],"mappings":"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"}